"use strict";(self.webpackChunkdocusaurus_demo=self.webpackChunkdocusaurus_demo||[]).push([[473],{7168:(n,e,r)=>{r.d(e,{R:()=>i,x:()=>l});var t=r(30758);const o={},s=t.createContext(o);function i(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:i(n.components),t.createElement(s.Provider,{value:e},n.children)}},34258:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"algorithm/tree/traverse","title":"\u904d\u5386","description":"\u6811\u7684\u904d\u5386\u4e3b\u8981\u5206\u524d\u3001\u4e2d\u3001\u540e\u5e8f\uff0c\u6bcf\u79cd\u904d\u5386\u90fd\u53ef\u4ee5\u5206\u522b\u7528\u9012\u5f52\uff08recursion\uff09\u548c\u5faa\u73af\uff08iteration\uff09\u6765\u5b9e\u73b0\u3002","source":"@site/docs/algorithm/tree/traverse.md","sourceDirName":"algorithm/tree","slug":"/algorithm/tree/traverse","permalink":"/docs/algorithm/tree/traverse","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"\u904d\u5386"},"sidebar":"algorithm","previous":{"title":"\u5b50\u5b57\u7b26\u4e32\u67e5\u627e","permalink":"/docs/algorithm/string/substring_search"},"next":{"title":"\u5e76\u67e5\u96c6","permalink":"/docs/algorithm/graphs/union-find"}}');var o=r(86070),s=r(7168);const i={title:"\u904d\u5386"},l=void 0,a={},d=[{value:"Pre-order",id:"pre-order",level:2},{value:"In-order",id:"in-order",level:2},{value:"Post-order",id:"post-order",level:2}];function c(n){const e={a:"a",br:"br",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"\u6811\u7684\u904d\u5386\u4e3b\u8981\u5206\u524d\u3001\u4e2d\u3001\u540e\u5e8f\uff0c\u6bcf\u79cd\u904d\u5386\u90fd\u53ef\u4ee5\u5206\u522b\u7528\u9012\u5f52\uff08recursion\uff09\u548c\u5faa\u73af\uff08iteration\uff09\u6765\u5b9e\u73b0\u3002"}),"\n",(0,o.jsx)(e.h2,{id:"pre-order",children:"Pre-order"}),"\n",(0,o.jsxs)(e.p,{children:["root -> left -> right",(0,o.jsx)(e.br,{}),"\n",(0,o.jsx)(e.a,{href:"https://leetcode.com/problems/binary-tree-preorder-traversal/",children:"Leetcode 144"})]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\n\n// Recursion\nfunction preorderTraversal(root) {\n    const result = [];\n    pre(root, result);\n    return result;\n};\n\nfunction pre(node, result) {\n    if (!node) {\n        return;\n    }\n    result.push(node.val);\n    pre(node.left, result);\n    pre(node.right, result);\n}\n\n// Iteration\nfunction preorderTraversal(root) {\n    const stack = [root];\n    const result = [];\n    let node;\n    while (node = stack.pop()) {\n        result.push(node.val);\n        if (node.right) {\n            stack.push(node.right);\n        }\n        if (node.left) {\n            stack.push(node.left);\n        }\n    }\n    \n    return result;\n};\n\n"})}),"\n",(0,o.jsx)(e.h2,{id:"in-order",children:"In-order"}),"\n",(0,o.jsxs)(e.p,{children:["left -> root -> right",(0,o.jsx)(e.br,{}),"\n",(0,o.jsx)(e.a,{href:"https://leetcode.com/problems/binary-tree-inorder-traversal/",children:"Leetcode 94"})]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\n\n// Recursion\nvar inorderTraversal = function(root) {\n    const result = [];\n    inoder(root, result);\n    return result;\n};\n\nconst inoder = function(node, result) {\n    if (!node) {\n        return;\n    }\n    inoder(node.left, result);\n    result.push(node.val);\n    inoder(node.right, result);\n};\n\n\n// Iteration\nvar inorderTraversal = function(root) {\n    const result = [];\n    const stack = [];\n    while (root || stack.length()) {\n        if (root) {\n            stack.push(root);\n            root = root.left;\n        } else {\n            root = stack.pop();\n            result.push(root.val);\n            root = root.right;\n        }\n    }\n\n    return result;\n};\n\n\n"})}),"\n",(0,o.jsx)(e.h2,{id:"post-order",children:"Post-order"}),"\n",(0,o.jsxs)(e.p,{children:["left -> right -> root",(0,o.jsx)(e.br,{}),"\n",(0,o.jsx)(e.a,{href:"https://leetcode.com/problems/binary-tree-postorder-traversal/",children:"Leetcode 145"})]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-javascript",children:"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\n\n\n// Recursion\nvar postorderTraversal = function(root) {\n    const result = [];\n    postorder(root, result);\n    return result;\n};\n\nconst postorder = function(node, result) {\n    if (!node) {\n        return;\n    }\n    postorder(node.left, result);\n    postorder(node.right, result);\n    result.push(node.val);\n}\n\n// Iteration\nvar postorderTraversal = function(root) {\n    const result = [];\n    const stack = [root];\n    while (stack.length) {\n        const node = stack.pop();\n\n        if (!node) {\n            continue;\n        }\n\n        result.unshift(node.val);\n        stack.push(node.left);\n        stack.push(node.right);\n    }\n    return result;\n};\n\n"})})]})}function u(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(c,{...n})}):c(n)}}}]);