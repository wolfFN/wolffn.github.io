<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Theo's Documentation Site Blog</title>
        <link>https://wolffn.github.io/blog</link>
        <description>Theo's Documentation Site Blog</description>
        <lastBuildDate>Wed, 07 Oct 2020 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <item>
            <title><![CDATA[【转载】30条编程名言佳句]]></title>
            <link>https://wolffn.github.io/blog/2020/10/07/30条编程名言佳句</link>
            <guid>【转载】30条编程名言佳句</guid>
            <pubDate>Wed, 07 Oct 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[以下内容收集自一些优秀的技术书籍章节开头的名言佳句，非常有意思，直接或间接反映了软件开发中的一些事情。]]></description>
            <content:encoded><![CDATA[<blockquote><p>以下内容收集自一些优秀的技术书籍章节开头的名言佳句，非常有意思，直接或间接反映了软件开发中的一些事情。  </p></blockquote><blockquote><p>网上很多，都是转载，未找到原作者，故未附出处</p></blockquote><p>生命太短暂，不要去做一些根本没有人想要的东西。——Ash Maurya</p><p>如果你交给某人一个程序，你将折磨他一整天；如果你教某人如何编写程序，你将折磨他一辈子。——David Leinweber</p><p>软件设计有两种方式：一种方式是，使软件过于简单，明显没有缺陷；另一种方式是，使软件过于复杂，没有明显的缺陷。——C.A.R. Hoare</p><p>其实，我尝试着使 Ruby 更自然，而不是简单。Ruby 看起来很简单，但内部是非常复杂的，就像我们的身体一样。——松本行弘，Ruby 之父</p><p>大部分情况下，构建程序的过程本质上是对规范调试的过程。——Fred Brooks，《人月神话》作者</p><p>软件开发往往是这样：最开始的 90% 代码占用了开始的 90% 的开发时间；剩下 10% 代码同样需要 90% 的开发时间。——Tom Cargill</p><p>当你试图解决一个你不理解的问题时，复杂化就产成了。——Andy Boothe</p><p>用几个小时来制定计划，可以节省几周的编程时间。—— 匿名</p><p>控制复杂性是计算机编程的本质。—— Brian Kernighan</p><p>计算机科学领域的所有问题都可以通过其他方式间接解决。——David Wheeler</p><p>编程是两队人马在竞争：软件工程师努力设计出最大最好的连白痴都会使用的程序；而宇宙在拼命制造最大最好的白痴。到目前为止，宇宙是胜利者。—— Rick Cook</p><p>调试一个初次见到的代码比重写代码要困难两倍。因此，按照定义，如果你写代码非常巧妙，那么没有人足够聪明来调试它。—— Brian W. Kernighan</p><p><img src="/img/blog/inspirational-quotes/steve-jobs.jpg" alt="Steve Jobs"/></p><p>我不是一个伟大的程序员，我只是一个具有良好习惯的优秀程序员。― Kent Beck</p><p>你们中大多数人都熟悉程序员的美德，有三种：那就是懒惰、急躁和傲慢。- Larry Wall，Perl 語言发明人</p><p>任何一个傻瓜都会写能够让机器理解的代码，只有好的程序员才能写出人类可以理解的代码。——Martin Fowler</p><p>靠代码行数来衡量开发进度，就像是凭重量来衡量飞机制造的进度。——比尔·盖茨</p><p>这不是一个 bug，这只是一个未列出来的特性。——匿名</p><p>作为一个程序员，郁闷的事情是，面对一个代码块，却不敢去修改。更糟糕的是，这个代码块还是自己写的。—— Peyton Jones</p><p>它在我的机器上可以很好运行！——大部分程序员</p><p>能说算不上什么，有本事就把你的代码给我看看。——Linus Torvalds，Linux 之父</p><p>我认为对象就像是生物学里的细胞，或者网络中的一台计算机，只能够通过消息来通信——Alan Kay，Smalltalk 的发明人，面向对象之父</p><p>当你选择了一种语言，意味着你还选择了一组技术、一个社区。——Joshua Bloch</p><p>质量、速度、廉价，选择其中两个。——匿名</p><p>过早的优化是罪恶之源。——Donald Knuth</p><p>没有什么代码的执行速度比空代码更快。——Merb 核心原则</p><p>如果你是房间里最聪明的人，那么你走错房间了。——匿名</p><p>如果只需更改一个单一的代码行，你的部门需要花费多长时间？——Mary Poppendieck</p><p>九个人不能让一个孩子在一个月内出生。——Fred Brooks，《人月神话》作者</p><p>好代码本身就是最好的文档。当你需要添加一个注释时，你应该考虑如何修改代码才能不需要注释。——Steve McConnell，Code Complete 作者</p><p>一个人在教会电脑之前，别说他真正理解这个东西了。——Donald Knuth</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Create React App 中的 Webpack 优化]]></title>
            <link>https://wolffn.github.io/blog/2020/07/17/Create React App 中的 Webpack 优化</link>
            <guid>Create React App 中的 Webpack 优化</guid>
            <pubDate>Fri, 17 Jul 2020 00:00:00 GMT</pubDate>
            <description><![CDATA[Create React App 创建的工程，一段时间后，打包速度越来越慢。我对速度和打包体积做了初步的优化，本文记录大概过程。]]></description>
            <content:encoded><![CDATA[<p>Create React App 创建的工程，一段时间后，打包速度越来越慢。我对速度和打包体积做了初步的优化，本文记录大概过程。</p><h2>优化方式</h2><p>比较主流的优化方式有如下几种：</p><ol><li><code>react-scripts</code> 提供了 <code>eject</code> 的方式，将其托管的 <code>webpack</code> 配置全部弹出。<ul><li>优点：完全掌控配置。</li><li>缺点：代码包复杂度增加，而且是与业务逻辑无关的配置。</li></ul></li><li>自己维护一个包，替换 <code>react-scripts</code><ul><li>优点：完全掌控配置，不会给业务代码包增加复杂度，且可以跨项目使用</li><li>缺点：维护额外的包，发布等工作量</li></ul></li><li><code>react-app-rewired</code> + <code>customize-cra</code>，项目中替换部分配置<ul><li>优点：不需要额外围护代码包，与此同时不给业务代码包带来过多的额外内容。</li><li>缺点：隔靴搔痒的感觉。一些深度侵入的配置改动会比较麻烦。</li></ul></li></ol><p>综上，方案 2 应该是最佳选择。考虑到优化带来的效果不明，以及 2 的前期额外投入，我们暂时先采取方案 3，待效果明显或遇到瓶颈后，切换方案 2 。</p><h2>rewired</h2><p>安装依赖</p><pre><code class="language-shell">npm i -D react-app-rewired customize-cra
</code></pre><p>根目录创建文件 <code>config-overrides.js</code></p><pre><code class="language-javascript">/* config-overrides.js */

module.exports = function override(config, env) {
    //do stuff with the webpack config...
    return config;
};
</code></pre><p>修改 <code>package.json</code></p><pre><code class="language-json">/* package.json */
&quot;scripts&quot;: {
  &quot;start&quot;: &quot;react-app-rewired start&quot;,
  &quot;build&quot;: &quot;react-app-rewired build&quot;,
  &quot;test&quot;: &quot;react-app-rewired test&quot;,
  &quot;eject&quot;: &quot;react-scripts eject&quot;
}
</code></pre><h2>测量手段</h2><h4>打包体积</h4><p>最终校验手段，可以看每次打包后的输出，也可以在 Devtool -&gt; Networks 中看包大小。</p><p>优化过程中，我们引入 <code>BundleAnalyzerPlugin</code> 来查看 bundle 的组成。</p><pre><code class="language-shell">npm i -D webpack-bundle-analyzer
</code></pre><pre><code class="language-javascript">const { override, addWebpackPlugin } = require(&#x27;customize-cra&#x27;);

const BundleAnalyzerPlugin = require(&#x27;webpack-bundle-analyzer&#x27;)
    .BundleAnalyzerPlugin;

module.exports = override(addWebpackPlugin(new BundleAnalyzerPlugin()));
</code></pre><p>加入插件后，打包结束后会在 <code>127.0.0.0:8888</code> 通过可视化手段展示打包组成图。</p><h4>速度</h4><p>通过 <code>time</code> 命令可以直观查看。</p><pre><code class="language-shell">time npm run build
</code></pre><p>优化过程中，为了方便查看各个步骤所用时间，我们引入 <code>SpeedMeasurePlugin</code>。</p><pre><code class="language-shell">npm i -D speed-measure-webpack-plugin
</code></pre><pre><code class="language-javascript">const SpeedMeasurePlugin = require(&#x27;speed-measure-webpack-plugin&#x27;);
const useSMP = config =&gt; new SpeedMeasurePlugin().wrap(config);

module.exports = override(useSMP);
</code></pre><h2>SourceMap</h2><p><a href="https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/config/webpack.config.js">react-scripts</a> 中关于 <code>devtool</code> 的配置如下：</p><pre><code class="language-javascript">devtool: isEnvProduction
  ? shouldUseSourceMap
    ? &#x27;source-map&#x27;
    : false
  : isEnvDevelopment &amp;&amp; &#x27;cheap-module-source-map&#x27;,
</code></pre><p>显然，在 prod 环境使用 source-map 意义不大。所以此处我们对该配置进行覆盖。</p><pre><code class="language-javascript">const rewiredMap = config =&gt; {
    config.devtool =
        config.mode === &#x27;development&#x27; ? &#x27;cheap-module-source-map&#x27; : false;

    // only for debug in test env
    // config.devtool = &#x27;source-map&#x27;;
    return config;
};

module.exports = override(rewiredMap);
</code></pre><p>此外，如果未在项目中对 webpack 进行 override，通过对环境变量赋值也可以达到该目的。只需要修改 <code>package.json</code>。</p><pre><code class="language-json">&quot;build&quot;: &quot;GENERATE_SOURCEMAP=false react-scripts build&quot;,
</code></pre><h2>HappyPack</h2><p><a href="https://github.com/amireh/happypack">Happy Pack</a> 通过将打包过程并行，进行优化。由于该配置对已有配置侵入性比较强，我选择了<code>react-app-rewire-happy-pack</code> 来处理这一过程</p><pre><code class="language-shell">npm i -D react-app-rewire-happy-pack
</code></pre><pre><code class="language-javascript">const rewireHappyPackLoader = require(&#x27;react-app-rewire-happy-pack&#x27;);
const useHappyPack = config =&gt; rewireHappyPackLoader(config);

module.exports = override(useHappyPack);
</code></pre><p>遗憾的是，该步骤并未能压缩打包时间，反而加长了打包时间。初步推测可能 webpack 自己对该部分进行了优化，而该 package 已经很久没有新的发布，可能未适配 webpack 的更新。</p><p>社区还有其他一些并行打包方案，后续可以研究下。</p><h2>Externals</h2><p>该配置主要是抽出项目中的依赖，将其在 html 中以 link 或 script 的形式引入。既降低了打包体积，又减少了打包时间。</p><p>首先找到这些依赖的打包版本。可以查看其官网，也可以直接去 cdn 网战找，推荐 <a href="https://www.bootcdn.cn/">bootcdn</a>。</p><p>然后下载这些打包文件，发布到 cdn。如果个人项目，可以直接使用 bootcdn 的版本。公司项目，还是不要偷懒，发布到公司的 cdn 或者其他付费 cdn，避免依赖引起的可用性问题。</p><p>接下来，在 <code>public/index.html</code> 中添加链接。</p><pre><code class="language-html">&lt;link
    href=&quot;//cdn.bootcdn.net/ajax/libs/antd/4.3.4/antd.min.css&quot;
    rel=&quot;stylesheet&quot;
/&gt;

&lt;script src=&quot;//cdn.bootcdn.net/ajax/libs/react/16.12.0/umd/react.production.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;//cdn.bootcdn.net/ajax/libs/react-dom/16.12.0/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;//cdn.bootcdn.net/ajax/libs/redux/4.0.5/redux.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;//cdn.bootcdn.net/ajax/libs/lodash.js/4.17.15/lodash.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;//cdn.bootcdn.net/ajax/libs/moment.js/2.27.0/moment.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;//cdn.bootcdn.net/ajax/libs/moment.js/2.27.0/locale/zh-cn.min.js&quot;&gt;&lt;/script&gt;

&lt;script src=&quot;//cdn.bootcdn.net/ajax/libs/antd/4.3.4/antd-with-locales.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>最后，override config</p><pre><code class="language-javascript">const useExternal = config =&gt; {
    config.externals = {
        react: &#x27;React&#x27;,
        &#x27;react-dom&#x27;: &#x27;ReactDOM&#x27;,
        redux: &#x27;Redux&#x27;,
        lodash: &#x27;_&#x27;,
        moment: &#x27;moment&#x27;,
        &#x27;moment/locale/zh-cn&#x27;: &#x27;moment.locale&#x27;,
        antd: &#x27;antd&#x27;,
    };

    return config;
};

module.exports = override(useExternal);
</code></pre><p><code>antd</code> 里面国际化相关的代码，还要做一点改动</p><pre><code class="language-javascript">// import zhCN from &#x27;antd/es/locale/zh_CN&#x27;;
import { locales } from &#x27;antd&#x27;;

ReactDOM.render(
    &lt;ConfigProvider locale={locales.zh_CN}&gt;
        &lt;App /&gt;
    &lt;/ConfigProvider&gt;,
    document.getElementById(&#x27;root&#x27;),
);
</code></pre><p>经过这些操作后，打包时间大幅减少，bundle analyzer 中依赖所占比例也降低了很多。</p><p>该过程中，我发现了社区有一个 package，可以通过配置的方式增加 external。这样写法更优雅一些，同时打包时间还减少了。。。我实在是不知道为什么。</p><pre><code class="language-shell">npm i -D html-webpack-externals-plugin
</code></pre><pre><code class="language-javascript">const HtmlWebpackExternalsPlugin = require(&#x27;html-webpack-externals-plugin&#x27;);

const externals = [
    {
        module: &#x27;antd&#x27;,
        entry:
            &#x27;//cdn.bootcdn.net/ajax/libs/antd/4.3.4/antd-with-locales.min.js&#x27;,
        global: &#x27;antd&#x27;,
    },
    {
        module: &#x27;antd-css&#x27;,
        entry: &#x27;//cdn.bootcdn.net/ajax/libs/antd/4.3.4/antd.min.css&#x27;,
    },
];

module.exports = override(
    addWebpackPlugin(new HtmlWebpackExternalsPlugin({ externals })),
);
</code></pre><h2>TODO</h2><p>上述就是我的初步优化。属于比较粗糙的对最明显的步骤的优化，肉眼可见的速度优化，后续细节优化还需要进一步研究。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[QCon上海2019见闻]]></title>
            <link>https://wolffn.github.io/blog/2019/10/23/QCon上海2019见闻</link>
            <guid>QCon上海2019见闻</guid>
            <pubDate>Wed, 23 Oct 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[前段时间有幸去上海参加了Qcon，聆听了业界一些优秀经验、实践的分享，感觉收获很大。尤其对两个分享感触比较深，分别是美团田泱同学分享的： 《云+端一体化：前端工程化探索》，以及字节跳动艾石光同学分享的《微前端在字节跳动的落地》。两个分享虽然落地点不同，但是解决的却是同一个问题：开发效率。]]></description>
            <content:encoded><![CDATA[<p>前段时间有幸去上海参加了Qcon，聆听了业界一些优秀经验、实践的分享，感觉收获很大。尤其对两个分享感触比较深，分别是美团田泱同学分享的： 《云+端一体化：前端工程化探索》，以及字节跳动艾石光同学分享的《微前端在字节跳动的落地》。两个分享虽然落地点不同，但是解决的却是同一个问题：开发效率。</p><h2>微前端在字节跳动的落地</h2><h3>问题</h3><ul><li><p>Monolithic 应用，build / deploy / rollback 慢，无法应对应用体量增大后，大量上线诉求。</p></li><li><p>框架无法调整</p></li><li><p>工程巨大难以理解，消耗过多认知资源</p><blockquote><p>每个人认知是一个有限的资源池，做一件事情时，牺牲掉注意力越多，分配到其他事情注意力越少；需要注意的东西越多，犯错的概率越大。</p></blockquote></li></ul><h3>解决方案</h3><h4>1. 服务发现</h4><p>将服务进行分拆，解除耦合。由此解决 Monolithic 应用带来的问题，实现独立运维，急速上线下线，流量分发，问题追踪。</p><h4>2. 运行隔离</h4><p>之前各个业务运行在一起，互相之间形成干扰，达到了一个很严重的程度。主要包括：</p><ol><li>一些模块/组件（或其依赖）对 Javascript 原型链的修改，对其他模块/组件形成干扰，带来bug。</li><li>CSS选择器互相干扰。</li></ol><p>主要通过 Sandbox 解决。为 CSS，DOM，变量、数据采集、sentry、localstorage 等添加沙盒。此外还引入了时序，并且对 polyfill 和其他 delete 情况作了特殊处理</p><h4>3. 环境一致</h4><p>这一块主要解决环境带来的问题。为了开发体验好，效率高，不论 serverless 还是 container，都坚持要有本地开发环境，并与线上保持一致。</p><p>通过命令启动 chrome ，leverage chrome 在 debug 方面的相关能力，引入对 timeout，memory，runtimes，API Gateway 等相关模拟。</p><h4>4. 其他</h4><p>拆分主工程和业务模块，统一数据采集、复杂事件分析。规范和灵活动态统一等。</p><h2>云+端一体化：前端工程化探索</h2><h3>问题</h3><p>田泱同学（以下简称”演讲者“）由三年前一次与老板的对话引出话题。当时的情景是，老板提出一个简单的需求，演讲者给了一个比较久的排期。老板对此不理解，认为不应该这么久。由此引起了演讲者对前端开发效率的思考，并为自己和团队提出了<strong>5分钟上线一个MVP项目</strong>的终极目标。</p><p>经过思考，前端开发效率低，主要问题是工程师距离业务逻辑较远，经常是支持多个业务，每个业务都不深入。团队组织不利于工程化。常见的团队划分方式有两种：</p><p><img src="/img/blog/QCon-2019/fe-team-func.jpg" alt="按职能划分"/></p><ul><li>按职能划分，一个大前端团队，支撑多个业务<ul><li>优点：氛围好，团队稳定</li><li>缺点：响应慢，协同效率低</li></ul></li></ul><p><img src="/img/blog/QCon-2019/fe-team-business.jpg" alt="按业务划分"/></p><ul><li>按业务线划分，分成多个小前端团队，嵌入各个业务team<ul><li>优点：响应快，协同效率⾼</li><li>缺点：氛围差，团队不不稳定</li></ul></li></ul><h3>解决方案</h3><h4>团队组织进化</h4><p>进阶：按业务划分基础上，增加基础服务团队，并且在业务小团队中，有部分力量支持基础服务。</p><p>基础团队主要职责：制定规范，制定框架，开发工具，其他服务。</p><p><img src="/img/blog/QCon-2019/fe-team-pro.jpg" alt="进阶"/></p><h4>团队合作</h4><p>职责清晰后，比之前的情况有了很大改观。即使如此，依然会有一些问题：</p><ul><li>基建同学：维护压力，业务方无法理解工具用法，需求又很多。</li><li>业务同学：成长诉求，以及可能对工具不满意。</li></ul><p>解决方案就是业务团队与基础服务团队的交集。可能是业务团队部分同学，做基础服务的业务；也可能是业务同学部分精力支持基础服务。基建团队承担主要维护压力，业务分摊部分功能的维护压力。交集存在后，合作流畅很多，基础团队能给给业务团队更多赋能。</p><h4>技术方案与流程规范</h4><p>分享者提出了一个开发实践中的效率公式：</p><pre><code>效率 = 技术方案的完善程度 x 流程规范的可执行性
</code></pre><ul><li>技术方案不完善：业务分摊部分功能维护压力，按层级分配职责同时，通过插件机制反哺：<ul><li>大前端委员会，各组TL：制定前端工程规范标准</li><li>各团队架构师：基于标准实现内核Loader，Tools工具链，以及Plugin插件。</li><li>各业务线骨干：开发适合特定业务场景的Template</li><li>各业务线的一线开发同学：基于Template进行二次开发</li><li>在此基础上，各个业务线的骨干、一线开发同学，通过贡献Plugin插件，反哺架构师的工作。</li></ul></li><li>流程规范不彻底：流程学习成本高，问题解决意愿低。<ul><li>主要通过GUI可视化工具解决。将流程，问题暴露在开发过程中。流程可视化，透明可见，执行成本更低。</li><li>GUI工具的主要功能：代码检查（兼容性，版本），Lint &amp; Test，Buid，Deploy，各个流程审批。</li></ul></li></ul><h4>Faas</h4><p>运维成本是阻碍 Node.js 在企业落地的绊脚石，通过 Faas 实现 Serverless，带来了耕地的学习成本、开发成本、运维成本。据演讲者称，能够带来20倍提升。主要有以下好处：</p><ul><li>运维托管，降低运维成本，”不用管“</li><li>无缝迁移，降低开发成本，利于方案推广，”不用学“</li><li>集中运行，充分利用机器资源，解决 nodejs 资源利用率低带来的浪费。与此同时，将 worker 分为以下两种模式，进一步提高资源利用率：<ul><li>Process模式，计算型，独享进程资源，通信效率低，适合计算型函数</li><li>Thread模式，响应型，共享进程资源，通信效率高，适合响应型函数，HTTP/MQ trigger</li></ul></li></ul><h2>Reference</h2><ul><li><a href="https://qcon.infoq.cn/2019/shanghai/presentation/2021">前端微服务在字节跳动的打磨与应用</a></li><li><a href="https://qcon.infoq.cn/2019/shanghai/presentation/2008">云+端一体化：前端工程化探索</a></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[《子弹笔记》行动指南]]></title>
            <link>https://wolffn.github.io/blog/2019/05/20/《子弹笔记》行动指南</link>
            <guid>《子弹笔记》行动指南</guid>
            <pubDate>Mon, 20 May 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[核心思想]]></description>
            <content:encoded><![CDATA[<h2>核心思想</h2><ul><li>集<strong>规划簿</strong>、<strong>日记本</strong>、<strong>笔记本</strong>、<strong>todo list</strong>、<strong>速写簿</strong>于一身。</li><li>想要成功应对周围世界，我们必须看清自己的内心。</li><li>动手写字 -&gt; 思想在神经层面沉浸于当下。</li><li><strong>整理思绪</strong>，从客观角度出发，审视自己的想法。</li><li>拒绝被动回应，开始主动应对</li><li>信息过载比筋疲力竭或吸食大麻更不利于我们集中注意力。</li></ul><h3>有意向性的生活</h3><p>遵循信念行动，描绘一个你坚信的，并能让你感动的生活故事。</p><h3>决策规避</h3><p>每天的生活中，我们都面对决策疲劳。抓住生活中每一个能够用来减少做选择的机会。</p><h3>&quot;长路即捷径&quot;</h3><p>真正的效率无关速度，在于为真正重要的事情留出了多少时间。
动手写字的意义：</p><ul><li>帮助记忆力欠佳的人保持条理</li><li>抵御年龄对记忆的损害</li><li>抓住慢慢思考的机会</li><li>把有价值的信息从喧嚣中摘选出来</li></ul><h2>结构</h2><h3>思想清单(P43)</h3><p>找一张纸，分三列，列出：</p><ol><li>正在做</li><li>应该做</li><li>想要做</li></ol><p>之后，在其中选出自己真正需要做的事情。如何判断：</p><blockquote><p>这件事情，紧急吗？重要吗？没完成会怎样？一直不完成会怎样？</p></blockquote><h3>笔记分类</h3><ol><li>Task<ul><li><code>.</code>，任务</li><li><code>x</code>，任务完成</li><li><code>&gt;</code>，迁移至下一个时间段，或个性化集子</li><li><code>&lt;</code>，暂时不做，迁移至Feature Log</li><li>横线划过的<code>.</code>，决定不做的任务</li><li><code>+</code> ，长篇笔记</li></ul></li><li>Event <code>。</code>，简明，客观，及时</li><li>Note <code>-</code> ，提炼和新，积极聆听，深度回顾；考虑可读性，写给未来的自己。</li><li>Signfier：<ul><li><code>*</code>，优先</li><li><code>!</code>，灵感</li><li><code>/</code>或<code>@</code>，由谁负责</li></ul></li></ol><h3>Collection</h3><h4>Index</h4><p><strong>4页</strong>，位于正本笔记开头，为collection、次集子提供专用索引。
可以使用引线法，连接不在一起的相关任务。
价值：一览时间、精力投向何方，在值得做的事情上保持专注。</p><h4>Future Log</h4><p><strong>2-4页</strong>。</p><ul><li>每日反思时，一部分任务迁移至Future；</li><li>月度规划时，从Future取出部分任务。</li></ul><h4>Monthly Log</h4><p><strong>2页</strong>，分别为：</p><ul><li>Calendar<ul><li>第一列留用做标记</li><li>第二列为日期、星期(比如，<code>1 一</code>，<code>13 五</code>)</li><li>第三列为日历事项或做过的事情，可以事后记录。</li></ul></li><li>Tasks，不断更新，梳理大脑。创建阅读记录时，从上月转移过来。</li></ul><h4>Daily Log</h4><p>每日记录，安心地表达自我。
主要内容是todo，record，需要提供对背景的认识，供翻阅反思
当天开始，或前一天晚上动笔</p><h4>个性化Collection</h4><p>来源：目标，难题，任务
步骤：头脑风暴，审视动机，设计，计划
计划（以旅行为例）：任务描述，目的地，活动，时间，预算
清单（有效辩解地整理内容）：分清主次，背景信息
行程：地点、时间、事件</p><h2>任务迁移</h2><h3>月度迁移</h3><h4>每月开始时，回顾上月任务：</h4><blockquote><p>为什么未完成？紧急吗？重要吗？未完成的后果？
剔除</p></blockquote><p><code>&gt;</code>，迁移至下月记录，个性化集子
<code>&lt;</code>，迁移至Future Log</p><h4>检查Future Log</h4><h3>年度迁移</h3><p>换新本，重新整理思想清单</p><h2>思想综述</h2><h3>自我探索</h3><p>我不会轻易说出这个词，但子弹笔记确实是探索自我这趟旅程的工具，它能帮助你发现你关心的事以及你想过的生活。着眼于如何以适应自我需求为目的提升你的子弹笔记。</p><p>你使用子弹笔记的时间越久，子弹笔记就越有益处。如果没能达到这种效果，那就问问自己为什么。是因为太费时？是因为为了让别人印象深刻而忽略了自己的需求？还是因为你没有取得进展？</p><p>子弹笔记有助于你推进自我探索这一旅程，让你了解如何把握自己的生命。这一切都取决于你是否愿意抛开限制，正视自己的潜能。在这一过程中，你要寻找勇气和执着，深入探究宇宙中难以承受的光辉，从而对自己的生活负责。</p><h3>聚焦当下</h3><p>其实，你拥有多少时间无关紧要，重要的是你能把多少注意力放在当下。控制注意力很难，因为我们的头脑是不称职的时间旅者，容易迷失于过去和未来。我们是否常常囿于自己无法改变的事情，或者担心我们无法预测的事情？这样的担忧会从我们真正能够做出改变的地方挪走大把的时间和精力，只有抓住此时此刻，我们才能够有所作为。
时间的质量取决于我们把握当下的能力。</p><p>达到心流状态的关键是在任务的难度与自己的技能水平之间找到平衡</p><h3>快乐</h3><p>谁都不知道究竟什么才能使自己快乐。
影响偏差（impact bias）：“容易高估某种未来情绪的持续时间和强度”。
快乐是我们着手进行其他目标时得到的结果。
如果快乐是行为的结果，那么我们就不该再问自己如何才能快乐了。相反，我们应该问问自己，要怎么做。</p><h3>好奇心 -&gt; 目标</h3><p>我们也有一个内在的机制来感知闪耀的事物，我们称之为：好奇心。
好奇心是我们在看到某种潜能时产生的触电般的兴奋劲。</p><p>目标的灵感启发应当源自自身的生活经历。不论是带给你欢乐的积极动力还是带给你悲惨教训的生活苦难，你的生活中肯定有真正的激情之源。把这些经历都运用起来！这些都是强有力的意义源泉，你可以从中找到有意义的目标。
抱着这一态度重新开始设定坐拥百万金钱的目标，比如可以这样：我要挣足够的钱来偿还学生贷款、购置一套两居室给退休的父母安享晚年、负担子女的学费。</p><p>尽管现在这个目标还是很宏大，但有了明确的意义。你清楚地知道这笔钱将如何改善你的生活。这一点至关重要。宏大的目标往往费时又费力，在这一路上你会面对各种挑战，耐力常常是你最狡猾、最致命的对手。因此，要实现宏大的目标，常常需要切实的需求来激励自己度过数日、数月，甚至数年的风风雨雨。这项需求必须要足够强劲，才能抵御一路上的分心、借口和疑惑。华裔心理学家安杰拉·李·达克沃斯（Angela Lee Duckworth）博士出版了《坚毅》（<em>Grit</em>）一书，她在书中写道，“对长期目标的坚毅与激情”激励成功的程度“胜过其他任何激励”。</p><h2>实践技巧</h2><h3>目标分解</h3><p>从大到小，可以将目标分为：</p><ul><li>长期目标</li><li>冲刺目标</li><li>任务
将长期目标分解为冲刺目标可以降低不堪重负和身心疲惫带来的风险。</li></ul><h4>设立冲刺目标的要求：</h4><ol><li><strong>初始阶段不要设立大的障碍（不能阻止你开始完成目标）。</strong></li><li><strong>具有清晰可行的任务步骤。</strong></li><li><strong>完成时间必须固定在短期之内</strong>（最多不能超过一个月，理想中应该在一至两周）。</li></ol><h4>开始分解目标前，再思考一下要做什么和为什么。</h4><ol><li><strong>这个目标为什么会激起我的好奇心？</strong></li><li><strong>是什么鼓励我为这个目标费时、费力？</strong></li><li><strong>是什么鼓励我为这个目标费时、费力？</strong></li><li><strong>有什么要求吗？</strong></li><li><strong>在这个目标上，我对成功的定义是什么？</strong></li></ol><h4>小目标反思</h4><ol><li>我了解了自身的哪些优缺点？</li><li>什么奏效了？什么没有奏效？</li><li>我还有什么改进空间？</li><li>我的生命增添了什么价值？</li></ol><h3>循序渐进</h3><p>通过把注意力放在小事上，我们既可以做到改变，又能避免不堪重负。我们要做的只是一次只解决一个问题。每一个解决方案都建立在先前的解决方案之上，因此，这些细化的步骤能很快积累起来，随着时间的推移实现巨大的改变。</p><h4>通过问问题的方法来激发好奇心和想象力。</h4><ol><li>我想做什么？</li><li>我为什么想这么做？</li><li>我可以从哪件小事开始？</li></ol><h4>就算某个人或某件事羁绊住你，你也很有可能找到突破口。</h4><ol><li>目前我能采取什么微小的措施推动进展？</li><li>目前我能改善的是什么？</li></ol><h4>遇到麻烦</h4><ol><li>究竟是哪里出了错？</li><li>为什么会出错？</li><li>下一次我能如何改进？</li></ol><h3>安排任务</h3><ul><li>把简单的事情都趁早做完也是一种拖延。</li><li>把烦心事趁早做完才会让接下来的一天轻松一些。</li><li>就好比负重跑步，卸下沙包的瞬间会觉得身轻如燕。</li></ul><h4>倒序排列任务的好处:</h4><ul><li>可以<strong>一步一步接近</strong>自己最感兴趣的任务。</li><li>有期盼会更容易保持一整天的专注和动力。<blockquote><p>需要说明的一点是，每个人的生物钟都不同，比如有的人越晚就越兴奋。因此，安排任务时的诀窍是找出自己最高效、最专注的时候，然后制订相应的计划。</p></blockquote></li></ul><h4>思考</h4><p>正念帮助我们<strong>抽身远观</strong>自己的想法。我的老师打了一个比方，把我们的想法比作汽车，冥想帮助我们站在路旁观察，而不是堵在马路中间。</p><p>在下次画掉笔记本上的任务时，慢下来，反思完成这一任务对你的影响。</p><ul><li>你有何感觉？如果什么感觉都没有，或者只感到如释重负，那么很有可能这项费力的任务并没有给你的生活带来多少价值。我们必须承认这一点。</li><li>但若你觉察到了一丝愉悦、自豪、感激、满足，那么你可能就有收获。给自己一小段时间体悟成就、感激成就，因为你会从这一过程中有所收获。毕竟，如果连你都无法欣赏自己的成就，这样的成就还有何意义呢？</li><li>成就能够滋养你、指引你，但是，在这之前，你必须花点时间感激自己取得的成就。</li></ul><h4>感恩</h4><p>1 在每日记、的夜反思中，写下至少一件让你感恩的事，养成习惯。
2 创建“感恩”集子，每天写下至少一件让你感恩的事，养成习惯。如果你热衷于此，你甚至可以带着创意来记录你最喜爱的瞬间。</p><h3>掌控</h3><blockquote><p>与其把查德约到门外了事，不如深吸一口气，等进行每日反思时再以更恰当的角度重新审视这件事。想想为什么他会这么说或者为什么他会这么做？为什么他会主动提出这个别有用心的看法？这个看法究竟为什么会激怒你？你的看法是什么？  </p></blockquote><blockquote><p>根据斯多葛学派的要义，我们无法掌控周围的世界以及其中的人。不自量力地否认这一真理只会让我们沮丧、受挫、完全迷失自我。</p></blockquote><p>比如：</p><ul><li>你提供了合理的建议，但是朋友不愿意采纳，直截了当地选择了相反的建议；</li><li>你没日没夜地加班，却得不到晋升的机会。</li><li>有的时候我们想要获得他人的认可和褒奖，但是常常得不到自己想象中的奖励，这时我们便会感到愤怒和困惑。</li><li>为什么我们的情绪会这么糟糕呢？因为我们对自己无法掌控的事情寄予了厚望。</li></ul><p>带着这些问题，在子弹笔记中写一封信记录自己斟酌过后的应对方案。这是为了让你厘清思路，为了让你看清怒气正盛时被掩藏了的机会和见解。这个方法帮助过我应对许多麻烦的人和事。</p><ul><li>首先，笔记本给了你一个安全的宣泄口，都写在纸上以后心情就已经平复了许多。</li><li>同时，纸上的想法也能凸显你卑鄙、无理或不理智的一面。</li><li>把这些负面情绪整理出来之后，你就能退后一步，以一种冷静的心态重新考虑这件事，想出有效的后续解决步骤。</li></ul><h4>忧虑</h4><blockquote><p>马克·吐温曾说：“我一生总在无止境地忧虑，其实很多担忧从未真正发生过。”
忧虑诱使我们以为这种情绪会带来解决方案，但通常并非如此。</p></blockquote><p>在进行日反思和夜反思以及月度迁移时，扫视一遍你的任务，试着分别找出受你掌控与不受你掌控的事。一个简单的分辨方法是观察这条任务是注重结果还是过程。</p><blockquote><p>如果我们没有意识到要对自己的卑劣品质负责（或者不愿意负责），我们就会不可避免地把这些负能量传递给附近的人。你的一言一行所带有的能量会改变周遭的世界和其中的人。</p></blockquote><p>比如：</p><ul><li>你对某个项目缺乏热情，整个团队都可能会被你拖垮。</li><li>再如，坏情绪可能会在你和同伴安静地共进晚餐时又默默回到你这里。</li></ul><p>情绪低落时，趁着做反思的时间看看这些记录，向自己展示证据，让自己接受证据。</p><p>消极或死气沉沉的人可能会破坏你用心生活的努力，试着与那些鼓舞你、激励你、提升你的人保持联系。问问自己：</p><ul><li>我能从他们身上学到什么？</li><li>他们的出现改善了我的世界吗？</li><li>他们激励我上进了吗？</li></ul><p>你无法改变身边人，但你可以更换身边人。</p><h3>拆解问题</h3><p>我们可以利用同样的方法解决自己的问题。在子弹笔记中创建一个新的集子，以遇到的问题为标题，比如，我付不起房租。现在开始问自己为什么，写下答案，然后再次提问为什么，质疑你的答案，一共问自己五个问题。</p><p><strong>我付不起房租。</strong>
1．为什么？因为我没钱。
2．为什么？因为租金太高。
3．为什么？因为这是个好地方。
4．为什么？因为我喜欢住在这里。
5．为什么？因为这里治安好、邻里友善、商店餐馆物美价廉。</p><p>现在，我们已经把一个难题拆解为五个小问题，可以有针对性地依次解决了。更重要的是，我们挖掘出了潜在的价值。我们常常会在拆解问题时发现真正濒临失去的东西。比如在这个例子中，房租其实不是关键，关键的是“我”不想失去住在这里的幸福感和安全感。有了这两条重要的信息后，我们便知道如何制订方案了。</p><p>我们面对的难题就如同镜子一般，折射出我们的脆弱、不安、弱点和恐惧。尽管问题艰巨，但不要退缩，勇敢地直视挑战、审视挑战，带着好奇面对自己的恐惧，然后你就会发现一条前进的道路。勇气会让你最终收获个人成长和专业进步，这是完全有可能的。如果你不奋勇向前，什么都得不到。</p><h3>橡皮鸭调试法</h3><p>重要的是把烦心事从你脑海中剔除。解释时要耐心、细心，毕竟你倾诉的对象可不像你一样掌握事情的来龙去脉。良好的沟通可以让对方不带偏差地理解实际情况。在详细叙述事情的过程中，我可能就已经找出应对方法了。</p><ul><li>你遇到的麻烦</li><li>出问题的地方</li><li>会出问题的原因</li><li>你尝试过的方法</li><li>还没尝试过的方法</li><li>你想要的结果</li></ul><h3>不完美</h3><p>不要视心神游荡为一种错误，而要视其为一种机遇。因为每当你回到现实中，你就变得更加专注于当下。
接受自己的不完美，知道自己会失败，我们就可以带着轻松的心情重新回到工作中。
优于别人并不高贵，真正的高贵应该是优于过去的自己。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[记一次对Koa.js middleware的源码贡献]]></title>
            <link>https://wolffn.github.io/blog/2018/07/06/记一次对Koa.js中间件的源码贡献</link>
            <guid>记一次对Koa.js middleware的源码贡献</guid>
            <pubDate>Fri, 06 Jul 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[本文主要记录笔者在使用开源Node.js web框架Koa.js过程中遇到的一个小bug，为修复此Bug查找Koa及其middleware源码的过程，以及最终发起Pull Request并被采纳的过程。]]></description>
            <content:encoded><![CDATA[<blockquote><p>本文主要记录笔者在使用开源Node.js web框架Koa.js过程中遇到的一个小bug，为修复此Bug查找Koa及其middleware源码的过程，以及最终发起Pull Request并被采纳的过程。</p></blockquote><h2>缘起</h2><p>事情的起因是这样的，在我刚入职当前公司时，由于团队组件不久，开发人员尚未配备期权，尤其缺乏服务端(<code>Java</code>)开发人员；而恰好有一个对内视频服务的需求比较紧急，所以本人虽然是一名（资深）前端工程师，依然主动承担起了<code>Server</code>端开发的责任。项目最终选择<code>FE</code>们最爱的<code>Node.js</code>进行开发，<code>web</code>框架则选择了<code>Koa.js</code>。</p><h2>问题</h2><p><code>Service</code>中有一个功能是为生成的视频提供下载功能。因为仅是内部人员下载，加上每天都要生成，所以决定直接在存储在服务器，然后提供链接供用户下载。</p><p>于是在服务端选择中间件<code>koa-static</code>，煎蛋设置一下缓存即可。主要代码如下：</p><pre><code class="language-javascript">const Koa = require(&#x27;koa&#x27;);
const serve = require(&#x27;koa-static&#x27;);

const app = new Koa();
app.use(
    serve(path.join(__dirname + &#x27;/dist&#x27;), {
        extensions: [&#x27;mp4&#x27;],
        maxage: 1000 * 60 * 60 * 24 * 100
    })
);
</code></pre><p>网页部分提供一个下载按钮，采用<code>a</code>标签加<code>download</code>，外面套<code>button</code>的形式，代码如下（vue）：</p><pre><code class="language-html">&lt;button&gt;&lt;a :href=&quot;video.outputPath&quot; download&gt;下载&lt;/a&gt;&lt;/button&gt;
</code></pre><p>于是，功能完成，顺利上线，运营小mm们效率提升，齐声夸赞，完满解决。</p><p>本集完。</p><hr/><p>如果生活是童话故事，那么上面便是结局。可惜，生活不是童话。</p><p>大概在今年（2018）2月左右，忽然大家反映，<strong>下载按钮</strong>不能用了，点击后，都是直接在新的<code>Tab</code>页打开链接。</p><h2>归因</h2><p>遇到bug后，第一反应是分析，能用 -&gt; 不能用 的过程中，发生了什么。经过大致判断，可以得出结论是<code>chrome</code>自动升级后，对<code>download</code>的支持发生了变化。</p><p>接下来，我的第一反应是，是不是<code>download</code>属性没有用好呢。于是去搜了搜标准，然后尝试给赋值，结果发现一样是不行。</p><p>这个时候我忽然想到，可以去看看别的网站，是否有同样的问题，以及怎么做的。</p><p>找了好久之后，发现了一个网站，视频还可以下载，于是在<code>chrome Develop Tools</code>的<code>Network</code>面板下，苦苦寻找差异。终于发现，在<code>Response Header</code>的<code>Content-Type</code>中存在差异。我的请求情况如下：</p><p><img src="/img/blog/Koa-send/content-type-mp4.jpg" alt="content-type-mp4"/></p><p>而可以下载的视频请求，内容则是：<code>Content-Type: video/mpeg4</code>。于是我怀疑，是不是浏览器把自己能够识别的扩展名直接打开，不能识别的则进行保存操作。那么接下来要做的事情就简单了：修改我们的响应头。</p><h2>初次尝试</h2><p>对于<code>npm</code>安装的package，个人建议直接去<a href="https://www.npmjs.com/">npm官网</a>搜索，一般都会提供源码地址，文档地址。</p><p>于是直接进入npm官网，搜索<code>koa-static</code>，进入<a href="https://www.npmjs.com/package/koa-static">该package主页</a>，发现如下内容：</p><blockquote><ul><li><a href="https://github.com/koajs/send#setheaders">setHeaders</a> Function to set custom headers on response.</li></ul></blockquote><p>既然官方直接提供了功能，那么事情好办了，直接加上吧。</p><p>修改Server端代码如下：</p><pre><code class="language-javascript">app.use(
    serve(path.join(__dirname + &#x27;/dist&#x27;), {
        extensions: [&#x27;mp4&#x27;],
        maxage: 1000 * 60 * 60 * 24 * 100,
        setHeaders: function (res) {
            res.setHeader(&#x27;Content-Type&#x27;, &#x27;video/mpeg4&#x27;);
        }
    })
);
</code></pre><p>欢天洗地，打开浏览器刷新重试，结果呢，无效！</p><h2>深入源码探索</h2><blockquote><p>柴犬屁股一沉，发现事情并不简单  </p></blockquote><p><img src="/img/blog/Koa-send/dogs.jpeg" alt="柴犬屁股一沉，发现事情并不简单"/></p><p>文档救不了我们，只能去看源码了。好在这些中间件一般都短小精悍并且逻辑严谨，读一读还是很有价值的。</p><p>对于node/js的项目，用到的package，直接打开项目目录下的<code>node_modules</code>找到对应目录阅读就可以了，十分方便。PS：大多数package入口在目录下的	<code>index.js</code> 文件。</p><p>打开<code>node_modules/koa-static/index.js</code>后，发现<code>koa-static</code>直接把传入的<code>options</code>原封不动传递给了<code>koa-send</code>：</p><pre><code class="language-javascript">function serve (root, opts) {
    ......
done = await send(ctx, ctx.path, opts)
</code></pre><p>于是继续，打开<code>node_modules/koa-send/index.js</code>，仔细阅读代码，发现对options中的<code>setHeaders</code>处理如下：</p><pre><code class="language-javascript">// 此处为一个Assertion，若setHeaders不是函数，直接抛出错误
const setHeaders = opts.setHeaders
if (setHeaders &amp;&amp; typeof setHeaders !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;option setHeaders must be function&#x27;)
}
......
// 如果是函数，则将其加入到reponse header
if (setHeaders) setHeaders(ctx.res, path, stats)
</code></pre><blockquote><p>这里关于Assertion可以多说一句，断言是编程中很使用的一种技巧，不管是开发、调试过程中快速发现错误，还是线上的防御性编程。在《代码大全》等经典书籍中都有介绍，推荐大家阅读相关章节。</p></blockquote><p>这么看没问题啊，传入的config应该都使用了啊。于是继续往下读，发现玄机：</p><pre><code class="language-javascript">ctx.type = type(path, encodingExt)
...

/**
 * File type.
 */
function type (file, ext) {
  return ext !== &#x27;&#x27; ? extname(basename(file, ext)) : extname(file)
}
</code></pre><p>原来，在setHeader之后，源代码又根据文件扩展名，修改了其content-type。为了验证自己的想法，我简单修改这里的代码，进行尝试：</p><pre><code class="language-javascript">if (!ctx.type) ctx.type = type(path, encodingExt)
</code></pre><p>重启服务，刷新后，发现效果如下：
<img src="/img/blog/Koa-send/content-type-mpeg4.jpg" alt="content-type-mpeg4"/></p><p>果然ok了。</p><h2>Pull Request</h2><p>既然折腾了这么一大圈，解决了问题，于是我决定一不做二不休，直接给<code>koa-send</code>开源项目Pull Request，如果被采纳，还算是给开源届做了Contribution。</p><p>过程很简单，到项目主页，fork项目。到自己主页，把fork的项目checkout到本地，修改代码，commit, push。</p><p>修改的代码很简单，但是注意，这些开源项目一般会有很重视测试，所以如果有UT，一定记得添加用例。我的代码具体如下（提交内容不包含注释）：</p><pre><code class="language-javascript">// 删除原来代码：ctx.type = type(path, encodingExt)
if (!ctx.type) ctx.type = type(path, encodingExt)

// 添加Test Case
it(&#x27;should set the Content-Type&#x27;, function (done) {
    const app = new Koa()

    app.use(async (ctx) =&gt; {
      await send(ctx, &#x27;/test/fixtures/user.json&#x27;)
    })

    request(app.listen())
    .get(&#x27;/&#x27;)
    .expect(&#x27;Content-Type&#x27;, /application\/json/)
    .end(done)
})
</code></pre><p>然后到还是到自己fork的项目中，选择第二个Tab：<code>Pull requests</code>，然后点击<code>New pull request</code>按钮，选择自己想提交的分支即可。</p><p><img src="/img/blog/Koa-send/pull-request.jpg" alt="pull-request"/></p><h2>结论</h2><p>发起请求后，项目维护者愉快的采纳了，于是我也有了对<code>Node.js</code>生态开源圈的第一次贡献，心里还是很高兴的。</p><p>Pull Request的地址在<a href="https://github.com/koajs/send/pull/105">这里</a>。</p><p>这件事情也给我带来了一定的思考，整理后，结论如下：</p><ol><li>写代码，解决问题，是充满快乐的，能够给我们带来满足感。</li><li>认真调研，阅读文档，甚至深入源码，问题总归是可以解决的。</li><li>我发现这些开源项目其实都有issue，并且有些维护者也公开说了<code>pull request is welcomed</code>，所以有时间可以多读一些源码，找机会多做一些贡献。</li></ol><p>以上就是这次修复bug、贡献源码的全过程以及给我带来的思考。只做了一点小小的工作，谢谢大家。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[写给Javascript程序员的Jupyter Notebook使用指北]]></title>
            <link>https://wolffn.github.io/blog/2018/06/14/写给Javascript程序员的Jupyter-Notebook使用指北</link>
            <guid>写给Javascript程序员的Jupyter Notebook使用指北</guid>
            <pubDate>Thu, 14 Jun 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[Jupyter Notebook是一块所见即所得的画布，通过在浏览器上编辑代码，让开发人员实现展示与快速迭代的利器。项目最初给予python，通过安装插件，对Javascript也有良好的支持。]]></description>
            <content:encoded><![CDATA[<blockquote><p> <a href="http://jupyter.org/">Jupyter Notebook</a>是一块所见即所得的画布，通过在浏览器上编辑代码，让开发人员实现展示与快速迭代的利器。项目最初给予python，通过安装插件，对Javascript也有良好的支持。</p></blockquote><blockquote><p> 本文主要针对前端/Javascript工程师在安装、配置的过程进行记录。希望notebook能给我们的开发、研究工作带来便利。</p></blockquote><h2>python工程师</h2><p>推荐专业的Python开发人员，安装<code>Anaconda</code>用以进行版本控制、包管理：</p><pre><code class="language-bash">brew cask install Anaconda
</code></pre><h2>前端(Javascript)工程师</h2><p>前端工程师使用notebook主要是为了运行js代码，所以没必要安装专业的<code>python</code>版本管理工具。直接通过<code>python3</code>以及<code>pip3安装即可</code>。具体安装方法如下：</p><h4>安装Jupyter Notebook</h4><pre><code class="language-bash"># 首先安装python3
brew install python3
python3 --version # 确认安装成功
pip3 --version # 确认pip3安装成功
pip3 install jupyter notebook 
# 此时已经安装成功，但是还没有对js的支持。
# 进入你希望存储notebook文件的目录，即可运行
cd ~/workspace/
mkdir my-notebooks
jupyter notebook
</code></pre><h4>安装对javascript的支持</h4><pre><code class="language-bash"># 安装对js的支持
npm i -g ijavascript
# 此时jupyter中还是没有对javascript的支持
# 手动进入ijavascript所在目录，执行一次.
cd /Users/[user-name]/.nvm/versions/node/v8.1.0/lib/node_modules/ijavascript/bin
./ijavascript.js

# 退出后再一次执行命令，就可以看到对js的支持了。
jupyter notebook
</code></pre><h4>使用npm package</h4><p>如果<code>notebook</code>仅仅支持<code>javascript</code>，而不支持广大的<code>npm packages</code>，相信对于我们没什么实质意义。所幸，只需要在<code>my-notebooks</code>目录初始化npm，然后安装所需package即可支持。</p><pre><code class="language-bash">npm init
npm i lodash -S
</code></pre><p>安装过后，效果如下：
<img src="/img/blog/Jupyter/npm-support.png" alt="npm-support.png"/></p><h4>安装对ES6的支持</h4><p><code>ijavascript</code>作者创建了一个新包<a href="https://github.com/n-riesco/jp-babel">jp-babel</a>来支持<code>ES6</code>。
与<code>ijavascript</code>一样，通过<code>npm</code>全局安装，再进入到其所在目录下的<code>bin</code>目录运行<code>jp-babel.js</code>一次即可。之后每次启动<code>jupytor notebook</code>，选择对应类型即可。如下图。</p><pre><code class="language-bash"># 安装对ES6的支持
npm install -g jp-babel
# 与ijavascript一样，首次运行需要进入目录并执行
cd /Users/[user-name]/.nvm/versions/node/v8.1.0/lib/node_modules/ijavascript/bin/jp-babel
./jp-babel.js
</code></pre><p><img src="/img/blog/Jupyter/ES6-support.png" alt="ES6-support.png"/></p><p>运行效果如下图：</p><p><img src="/img/blog/Jupyter/es6-output.png" alt="es6-output.png"/></p><p>唯一不完美的是，输入代码后，使用快捷键<code>Control + Enter</code>运行代码，在第二次时就会报错。可能因为是默认使用了严格模式。
解决方案是先点击菜单上的<code>Kernel -&gt; Interrupt</code>，然后再<code>Control + Enter</code>运行。当然，<code>Interrupt</code>也有快捷键，默认为<code>I,I</code>，如果使用不便（比如与<code>Vimium </code>插件冲突），在<code>Help -&gt; Edit Keyboard Shortcuts</code>中可以进行修改。</p><h2>结论</h2><p>以上就是<code>Jupyter Notebook</code>的安装，以及对<code>Javascript</code>支持配置的完整过程。有了她，我们不仅能在文档中执行代码，还能以网页形式分享。同时，通过重现整个分析过程，并将说明文字、代码、图表、公式、结论都整合在一个文档中，与同行们进行有效沟通。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Chrome Dev Tools---[性能篇]]]></title>
            <link>https://wolffn.github.io/blog/2018/04/01/Chrome-Dev-Tools-性能篇</link>
            <guid>Chrome Dev Tools---[性能篇]</guid>
            <pubDate>Sun, 01 Apr 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[本文主要记录Chrome Dev Tools 关于性能调优的使用方法。基础用法请参见基础篇]]></description>
            <content:encoded><![CDATA[<blockquote><p>本文主要记录Chrome Dev Tools 关于性能调优的使用方法。基础用法请参见<a href="//wolffn.github.io/blog/2017/11/15/Chrome-Dev-Tools-%E5%9F%BA%E7%A1%80%E7%AF%87/">基础篇</a>  </p></blockquote><h2>Performance</h2><ul><li>与<code>loading</code>相对,是<code>running</code>的性能,找出页面性能瓶颈,建议:<ul><li>在<code>隐身模式下</code>使用.</li><li><code>Capture Settings</code>-&gt;<code>20x slowdown</code>(for mobile)</li></ul></li><li>右键 -&gt; <code>Save profile</code>/ <code>Load profile</code></li><li><code>Record</code>结果分析:<ul><li><code>FPS</code>出现红色时,说明丢帧严重,绿色越高,性能越好.</li><li><code>CPU</code>与底部的<code>Summary</code>相呼应,当该栏被颜色填满时，说明<code>CPU</code>满负荷.</li><li>鼠标悬浮于<code>FPS</code>,<code>CPU</code>,<code>NET</code>上面时,可以看到放大的screenshot</li><li>鼠标悬浮于<code>Frames</code>,查看FPS,不应高于60.</li><li><code>Frames</code>中,点击某一帧,<code>Summary</code>中显示Screenshot,点击可放大;此时若开启<code>Enable advanced paint instrumentation</code>,会显示<code>Layer</code></li><li><code>Interactions</code>:用户交互事件</li><li><code>Cmd + Shift + p</code>-&gt;<code>show rendering</code>,显示<code>Rendering</code> Tab</li><li><code>Overview</code>上点击、按住并移动鼠标,来聚焦某一个时间段.(或者使用W A S D键)</li></ul></li><li>找出瓶颈<code>bottleneck</code><ul><li><code>Summary</code>中,<code>Rendering</code>是否过多-&gt;减少<code>Rendiering</code></li><li><code>Memory</code>勾选后显示内存使用情况</li><li><code>Network</code>,左侧线:request sent之前的事件;浅色:request sent,waiting;深色:content download;右侧线:等待主进程.</li><li>展开<code>Main</code>,<code>x</code>:时间,越宽说明运行时间越长;<code>y</code>:callstack.</li><li><code>Main</code>中,Shift+鼠标选择区域,可以看到具体时间</li><li><code>Main</code>中,颜色随机分配,深黄色<code>Scriping</code>,紫色<code>Rendering</code>,</li><li><code>Main</code>中,事件右上角红色三角,说明很可能有性能问题.</li><li>点击<code>Main</code>中的事件,<code>Summary</code>中会显示详情,<code>reveal</code>跳转至相应code</li><li><code>console</code>旁边有<code>rendering</code>.<code>Paint Flashing</code> <code>layer borders</code> <code>scrolling performance issues</code></li><li>在调用栈最底层的紫色事件(Layout),放大后很可能也有红色三角,点击,再从<code>Summary</code>跳转至对应代码,可以发现右侧又事件,指示出强制重绘的事件.</li><li><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/performance-reference">事件类型参考</a></li></ul></li><li>查看调用栈,分析性能<ul><li>三个Tab均展示选中事件</li><li>右侧<code>Show Heaviest Stack</code></li><li><code>call tree</code>查找哪一个<code>root activity</code>消耗了最多的时间</li><li><code>bottom up</code>展示直接消耗时间的事件</li><li><code>event log</code>按调用顺序展示,<code>filter</code>选择事件类型</li></ul></li></ul><h2>Memory</h2><ul><li>Menu -&gt; More tools -&gt; Task manager 打开任务管理器<ul><li>右键点击表格标题 -&gt; 启用JavaScript memory</li><li><code>Memory</code>列表示原生内存，<code>JavaScript Memory</code>表示JS堆。</li></ul></li><li>内存术语<ul><li>对象可通过两种方式占用内存：<ul><li>直接通过对象自身占用，对象自身占用内存大小在分析结果中表现为<code>Shadow Size</code>。</li><li>通过保持对其他对象的引用隐式占用。对象本身、连同其无法从<strong>GC根</strong>到达的相关对象一起删除后释放的内存大小，在分析结果中表现为<code>Retained Size</code>。</li></ul></li><li><code>Distance</code>是指该内存节点与GC 根之间的距离。如果相同类型的几乎所有对象的距离都相同，只有少数对象的距离偏大，则有必要进行调查。</li></ul></li><li>Devtools -&gt; Performance面板 -&gt; 启用Memory复选框<ul><li>在记录时点击Collect garbage，可以强制垃圾回收。</li><li>Overview窗格中HEAP图表表示JS堆</li><li>最下方窗格为JS HEAP、Documents、Nodes、Listeners、GPU Memory</li></ul></li><li>使用堆快照，发现已从DOM Tree分离节点的内存泄漏。<ul><li>选择<code>Take Heap Snapshot </code>，然后点击<code>Take Heap Snapshot</code>按钮。</li><li>执行一段时间后，从左侧面板选择该快照，快照名字下方显示JS对象总大小。</li><li>Summary视图显示按构造函数名称分组的对象，Containment 视图提供了对象结构视图，有助于分析全局命名空间 (window) 中引用的对象以找出是什么让它们始终如影随形。使用此视图可以分析闭包以及在较低级别深入了解您的对象。</li><li>在<code>Summary</code>视图的 <strong>Class filter</strong> 文本框中键入 <code>Detached</code>，搜索已分离的 DOM 树。</li><li>展开三角符号，以黄色突出显示的节点具有 JavaScript 代码对它们的直接引用。</li><li>点击黄色节点，在 <strong>Object</strong> 窗格中，可以看到与正在引用该节点的代码相关的更多信息。 </li></ul></li><li>使用分配时间线确定 JS 堆内存泄漏<ul><li>选择<code>Record Allocation Timeline</code>单选按钮，按<code>Start</code>按钮，执行您怀疑导致内存泄漏的操作。完成后，按<code>stop recording</code>按钮。</li><li>点击记录的profile文件查看，选择展现形式为<code>Chart</code>。分配时间线上的蓝色竖线表示新内存分配。</li><li>点击下方内容，可以查看具体代码。</li></ul></li><li>按函数调查内存分配<ul><li>选择Record Allocation Profiler 类型，可以按照 JavaScript 函数查看内存分配。</li><li>点击<code>start</code>按钮，执行期望观察的操作，完成后点击<code>stop</code>。</li><li>Profile默认视图为 <strong>Heavy (Bottom Up)</strong>，将分配了最多内存的函数显示在最上方。</li></ul></li><li>发现频繁垃圾回收<ul><li>如果感觉页面经常暂停，则可能存在垃圾回收问题。</li><li>在任务管理器中，<strong>Memory</strong> 或 <strong>JavaScript Memory</strong> 值频繁上升和下降表示存在频繁的垃圾回收。</li><li>在<code>Timeline</code>记录中，JS 堆或节点计数图表频繁上升和下降指示存在频繁的垃圾回收。</li></ul></li></ul><h2>Application</h2><ul><li>storage: 查看local storage,session storage,IndexedDB,Web SQL,</li><li>Application Cache: 查看通过Application Cache API创建的资源和规则</li><li>Cache Storage: 查看Service Worker相关缓存</li><li>Clear Storage: 删除缓存</li><li>Cookies: 查看、删除cookie,不可修改</li><li>Frame: 安框架组织Resources<ul><li>右键-&gt;复制链接、在新页面中打开、保存、在Network中查看</li></ul></li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[效率至上-一文带你真正走进vim]]></title>
            <link>https://wolffn.github.io/blog/2018/03/31/效率至上-一文带你真正走进vim</link>
            <guid>效率至上-一文带你真正走进vim</guid>
            <pubDate>Sat, 31 Mar 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[vim一直是程序员之间比较有争议的一个话题。有人认为她是编辑器之神，有人则认为她古老过时，远远不如IDE，或是以当红小生vscode为代表的图形化文本编辑器。无论爱恨，我们的开发工作，大到远程登录服务器coding，修改config文件，小到git commit message，或多或少总要接触她。]]></description>
            <content:encoded><![CDATA[<p><code>vim</code>一直是程序员之间比较有争议的一个话题。有人认为她是编辑器之神，有人则认为她古老过时，远远不如<strong>IDE</strong>，或是以当红小生<code>vscode</code>为代表的<strong>图形化文本编辑器</strong>。无论爱恨，我们的开发工作，大到远程登录服务器<code>coding</code>，修改<code>config</code>文件，小到<code>git commit message</code>，或多或少总要接触她。</p><p>为什么要写这篇blog呢，是因为我发现各大平台充斥的<code>vim</code>教程类blog其实很不友好，大多数是命令的堆砌，很少有对思想的解读。由此造成的结果，很多工程师对<code>vim</code>总是敬畏三分，或者就算部分人可以使用<code>vim</code>，也只是以自己的固有思维，结合vim的命令操作，并没有真正掌握<code>vim</code>的精髓。所以我尝试用自己的方式，试图帮助大家<strong>系统</strong>地建立起<code>vim</code>的知识系统。</p><p>文章主要结构如下：</p><ul><li>首先介绍<code>vim</code>编辑器最简单、基本的操作，让你快速入门，在遇到<code>vim</code>时，可以不至于惊慌，从容完成任务。如果想到某些操作，比如常用的复制、粘贴之类，可以到第二部分查找对应高阶操作，循序渐进使用<code>vim</code>。</li><li>接下来，将会介绍<code>vim</code>一系列高级操作，将我们的效率最大化。注：这部分信息量较大，建议您在阅读部分内容后，快速浏览不熟悉的命令，做到心中有数；随后可前进到第三部分；回过头来，再循序渐进，边学边练。</li><li>最后，试图讲述<code>vim</code>思想的精髓，既让我们真正对<code>vim</code>的操作融会贯通，又让我们可以在使用其他IDE/编辑器时应用这些思想，甚至在我们自己设计、实现功能、组件时，都能进行应用。这才算真正掌握了神器<code>vim</code>。</li></ul><h1>模式</h1><p>vim有三个模式，分别为普通（正常）模式、插入模式以及命令模式。</p><ul><li>普通模式：一般用于浏览文件，也包括一些复制、粘贴、除等操作。</li><li>插入模式：主要用来输入、修改、删除字符，此时的操作，除了不能用鼠标外，与我们日常在编辑器中操作无异。普通模式下，通过<code>i</code>等命令进入插入模式。</li><li>命令模式：用以执行一些输入并执行一些vim或插件提供的指令。在普通模式下通过输入<code>:</code>后，可以发现，屏幕的右下角会出现<code>:</code>，此时便进入了命令模式。本文中使用<code>：</code>开头的命令，便可视为输入<code>:</code>进入命令模式后，输入后面的字符，执行命令。</li></ul><p>很多人对于<code>vim</code>的第一点疑惑，便来源于此。我们习惯了图形化编辑器下，始终处于插入状态。然而在<code>vim</code>中，大多数情况下，我们会处于正常模式。只有当需要输入字符时，进入插入模式；当需要使用命令时，进入到命令模式。在插入和命令模式下，输入<code>Esc</code>便可返回正常模式。一张图概括如下：</p><p><img src="/img/blog/vim/mode.png" alt="image"/></p><blockquote><p>注：后文讲解，如无特殊说明，均为普通模式下操作。</p></blockquote><h1>基本操作</h1><p>如果不追求效率，只想完成修改文件的任务，并保存退出，只需要掌握以下三个命令：</p><ol><li>移动：<code>h j k l</code> 最简单的移动，相当于键盘上面的方向键，分别对应左下上右。</li><li>进入插入模式：<code>i</code></li><li>保存退出：<code>ZZ</code>（注意区分大小写）</li></ol><p>流程如下：</p><ol><li>普通模式下，通过<code>h j k l</code> 移动到想要修改的位置</li><li>输入<code>i</code>进入插入模式，此时通过输入(字母、数字、符号)，删除(Backspace)等，完成基本修改操作</li><li><code>Esc</code>回到普通模式，<code>ZZ</code>，保存修改并退出。</li></ol><h1>进阶：命令形式</h1><p>普通模式下，<code>vim</code>的命令主要分为以下三种：</p><ol><li><p>动作，用以移动光标，或者定义操作的范围；比如：</p><ol><li><code>h</code>：定义操作范围为一格，单独使用时，向左移动光标一格。</li><li><code>w</code>：定义操作范围为一个单词，移动光标到下一个单词首部。</li></ol></li><li><p>操作，这种命令需要在后面接表示操作范围的指令；</p><ol><li><code>d</code>，删除，后接表示一个单词操作范围的<code>w</code>，即<code>dw</code>时，表示删除到当前词尾。</li><li><code>c</code>，修改，后接表示一个单词操作范围的<code>w</code>，即<code>cw</code>时，表示修改当前单词。(编辑器行为表现为，删除到当前词尾，同时进入插入模式)。</li></ol></li><li><p>命令，直接执行的命令，其中一部分，在执行命令后，直接进入编辑模式；比如：</p><pre><code>1.  `D`，删除至行末。
2.  `I`，到行首进入插入模式。
</code></pre><p>我们的使用方式主要也是三种：命令、动作、操作+动作。
此外，在<strong>动作</strong>类的命令前，加上<code>number</code>为可选项，可实现<code>重复n次</code>的效果：</p></li><li><p><code>[number] + h/j/k/l</code> 向<code>左/下/上/右</code>移动<code>number</code>个字符。比如，&#x27;2j&#x27;，向下移动光标2个字符。</p></li><li><p>依旧使用<code>d</code>和<code>w</code>来举例，<code>d</code>是删除，<code>w</code>是单词，<code>dw</code>代表删除一个单词，<code>d2w</code>代表删除两个单词。后面的命令，大多都可应用此种形式组合使用，大家多注意，养成这种<code>操作 + [次数] + 范围</code>的思维模式，举一反三，便可发挥最大功效。</p></li></ol><h2>移动进阶</h2><h4>单词级别的移动</h4><p>这里有仅大小写不同的两组命令，两组命令的功能，是相同的：跳转光标到对应位置。但是对应的单位不同，分别为<code>word</code>和<code>string</code>。具体区别是：</p><ul><li><p><code>string</code>仅以<strong>空格</strong>分开；</p></li><li><p><code>word</code>以<strong>字母数字以外的字符</strong>分开。</p><p>以这个字符串为例：<code>hello world-hehe111 abcde</code></p></li><li><p><code>word</code>有5个，分别为<code>hello</code>  <code>world</code>, <code>-</code>, <code>hehe111</code>和<code>abcde</code>。</p></li><li><p><code>string</code>有3个，分别为<code>hello</code>  <code>world-hehe111</code>和<code>abcde</code>。</p></li></ul><p>两组命令如下：（跳转光标至）</p><ul><li><p><code>w</code> 下一个单词开头</p></li><li><p><code>e</code> 当前或下一个单词结尾</p></li><li><p><code>b</code> 当前或上一个单词开头</p></li><li><p><code>ge</code> 上一个单词的结尾</p></li><li><p><code>W</code> 下一个字符串的开头</p></li><li><p><code>E</code> 当前或下一个字符串结尾</p></li><li><p><code>B</code> 当前或上一个字符串的开头</p></li><li><p><code>GE</code> 上一个字符串的结尾</p></li></ul><p>举个例子，当光标位于<code>hehe111</code>的第一个字符<code>h</code>时，前后的单词/字符串信息如下：</p><table><thead><tr><th></th><th>前一个</th><th>当前</th><th>后一个</th></tr></thead><tbody><tr><td>单词</td><td>-</td><td>hehe111</td><td>abcde</td></tr><tr><td>字符串</td><td>hello</td><td>world-hehe111</td><td>abcde</td></tr></tbody></table><p>那么以上各个敲击以上各个命令的结果，便一目了然(加粗字表示命令运行后光标位置)：</p><p><img src="/img/blog/vim/word-jump.png" alt="image"/></p><h4>句子，段落级别的移动</h4><ul><li><p><code>0</code> 移动到当前行行首</p></li><li><p><code>^</code> 移动到当前行的第一个非空字符</p></li><li><p><code>$</code> 移动到当前行尾</p></li><li><p><code>(</code> 跳转到当前或前一个句子的开头</p></li><li><p><code>)</code> 跳转到当前或下一个句子的结尾</p></li><li><p><code>{</code> 跳转到当前或前一个段落的开头</p></li><li><p><code>}</code> 跳转到当前或下一个段落的结尾</p></li><li><p>这里段落很容易理解，是以空行分隔开的。句子麻烦些，是按照句号来算的。</p></li><li><p>记得在这些命令前添加 <code>d</code>试一下效果吧，掌握<code>操作+范围</code>这种命令形式吧。</p></li></ul><h4>页面级别的移动</h4><h5>按行移动光标</h5><ul><li><code>gg</code> 移动到文本第一行行首</li><li><code>G</code> 移动到文本末行行首</li><li><code>[n] + %</code>：按百分比近似定位到某行，该行位于整个文件的<code>n%</code>处</li><li><code>[n] + gg/G</code> 跳转到第<code>n</code>行，常用。</li></ul><p>要想用好上述几个命令，有两个简单的建议：</p><ol><li>结合命令：<code>ctrl-g</code>。该命令的作用是显示当前行的位置信息（第几行，相对整个文本行数的百分比）。</li><li>在命令模式下输入以下命令，或在<code>~/.vimrc</code>中添加如下代码片段</li></ol><pre><code class="language-shell">set nu &quot; 显示行号
set cursorline &quot; 高亮光标所在行&lt;/pre&gt;
</code></pre><h5>显示页面内移动光标</h5><ul><li><code>H</code>：屏幕顶部行首</li><li><code>M</code>：屏幕中央行首</li><li><code>L</code>：屏幕底部行首</li></ul><h5>滚动与翻页</h5><ul><li><p><code>ctrl-d/u</code>：前进/后退半页</p></li><li><p><code>ctrl-f/b</code>：前进/后退整页</p></li><li><p><code>ctrl+e</code>：上滚一行</p></li><li><p><code>ctrl+y</code>：下滚一行</p></li><li><p><code>zt</code>：使光标所在位置移动到屏幕的顶部（所有内容做位移）</p></li><li><p><code>zz</code>：使光标所在位置移动到屏幕的中央（所有内容做位移）</p></li><li><p><code>zb</code>：使光标所在位置移动到屏幕的底部（所有内容做位移）</p></li></ul><h4>匹配</h4><ul><li><code>f+单个字符</code>：在本行内向右移动到指定字符</li><li><code>F+单个字符</code>：在本行内向左移动到指定字符</li><li><code>t+单个字符</code>：在本行内向右移动到指定字符的前一个字符</li><li><code>T+单个字符</code>：在本行内向左移动到指定字符的前一个字符</li><li><code>%</code>: 在“( )”、“<!-- -->[ ]<!-- -->”、“{ }”类符号的首尾间切换</li><li><code>*</code> 和 <code>#</code>: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个）。</li></ul><h4>Mark</h4><ul><li><code>m+[a~z]</code> ：在当前光标做标记，如ma</li><li><code>&#x27;+[mark]</code>：光标返回指定标记所在的行，如<code>&#x27;a</code>，则光标返回到标记<code>a</code>所在行首</li><li>&quot;`&quot;+<!-- -->[mark]<!-- -->：光标返回指定标记</li><li><code>ctrl+o</code>：跳转回光标前一个位置</li><li><code>ctrl+i</code>：跳转回较新的光标位置</li><li>建议结合命令模式下如下两个命令，可获得更好体验：<ul><li><code>:marks</code>：显示全部mark</li><li><code>:delmarks [mark]</code>：删除指定mark</li></ul></li></ul><h2>编辑进阶</h2><h4>进入插入模式</h4><h5>在不同位置进入插入模式</h5><ul><li><code>i</code>：在光标前插入字符</li><li><code>I</code>：在行首插入字符</li><li><code>a</code>：在光标后插入字符</li><li><code>A</code>：在行尾插入字符</li><li><code>o</code>：在光标下发插入空行</li><li><code>O</code>：在光标上方插入空行</li></ul><h5>使用修改命令进入插入模式</h5><ul><li><p><code>c</code>：修改，后面需要接范围</p></li><li><p><code>c+w</code>：删除光标位置单词，并进入插入模式</p></li><li><p><code>c+l / s</code>：删除光标位置字符，并进入插入模式</p></li><li><p><code>c+c / S</code>：删除光标所在行，并进入插入模式</p></li><li><p><code>c+$ / C</code>：删除光标位置到行尾的字符，并进入插入模式</p></li><li><p><code>r</code>： 替换当前字符。</p></li><li><p><code>R</code>：（进入replace模式）持续替换光标所在字符，直到使用ESC退出替换模式。</p></li></ul><h4>删除</h4><ul><li><p><code>x</code>： 删除当前位置或下一个位置的字符。</p></li><li><p><code>d</code>：删除，属于动作指令，后面需要加操作类指令。比如如下命令：</p><ul><li><code>de</code>：删除到当前单词结尾。</li><li><code>dw</code>：删除到下一个单词开始。</li><li>注意，此处与<code>de</code>的区别在于，<code>dw</code>会删除两个单词之间的空格。</li><li><code>daw</code>：删除一个单词，包含单词的边界（空格）。</li><li><code>d0</code>：删除至行首。</li><li><code>d$ / D</code>：删除至行尾。</li></ul></li><li><p><code>da[</code>：删除<!-- -->[ ]<!-- -->整个块，包含符号本身；</p></li><li><p><code>di[</code>：删除<!-- -->[ ]<!-- -->块，不包含符号本身；</p></li><li><p><code>da/di +</code> &#x27; &quot; { ( 等，也与接[类似，删除整个区块。唯一需要注意的，&quot;和&#x27;仅仅在行内。</p></li><li><p><code>dt[x]</code>：在本行，删除到<!-- -->[x]<!-- -->。比如，<code>dt&quot;</code>删除到双引号，<code>dtf</code>，删除到字母<code>f</code>。 <code>d/foo</code>：在全文， 删除到 “foo” 。</p></li></ul><h4>剪切</h4><p>剪切操作其实就是我们之前讲的删除。也就是<code>d</code>。删除的内容，默认会存放到剪切板中。也就相当于进行了剪切。</p><h4>进阶操作符</h4><p>从这里大家可以看出，<code>i</code>和<code>a</code>的作用比较特殊，代表与区块相关的某种操作。区别就在于，<code>i</code>不包含区块边界符号。<code>a</code>包含。这两个操作符很重要，在后面的复制操作中还会用到。此外还有<code>t</code>，<code>/</code>。此外，<code>i</code>和<code>a</code>还可以接<code>t</code>，此时<code>t</code>表示一对xml标签。<code>i</code>：区块，不包含边界。<code>a</code>：区块，包含边界。<code>t</code>：&quot;to&quot;，本行到哪里。<code>/</code>：接匹配，全文到哪里。</p><h4>粘贴</h4><ul><li><code>p</code>：粘贴到光标后，或下一行。</li><li><code>P</code>：粘贴到光标前，或前一行。</li></ul><p>为什么会有光标前后或上下一行两种情况呢？是因为我们复制或剪切的内容有可能是字符串或者整行：</p><ul><li>当复制内容为字符串时，粘贴到光标前/后。</li><li>当复制内容为整行时，粘贴到上/下一行。</li></ul><h4>复制</h4><ul><li><code>y</code>，复制，属于操作，后面需要接动作来标识复制的范围。比如：<ul><li><code>yw</code>：复制到当前单词结尾。</li><li><code>ye</code>：从当前位置复制到本单词的最后一个字符。</li><li><code>y$</code>：复制到当前行尾。</li><li><code>yy</code>或<code>Y</code>：复制当前行。</li><li><code>nyy</code>：复制从光标所在行起的n行，注意n在最前面。</li></ul></li></ul><p><code>0y$</code>： 命令意味着：</p><ul><li><code>0</code> → 先到行头</li><li><code>y</code> → 从这里开始拷贝</li><li><code>$</code> → 拷贝到本行最后一个字符</li></ul><p>当然也可以结合我们刚刚介绍的进阶操作符来进行操作：</p><ul><li><code>yi&quot;</code>：复制两个引号之间</li><li><code>yit</code>：复制两个xml标签之间</li><li><code>y/[x]</code>：复制到x。</li></ul><h4>剪切板</h4><p>vim 有 12 个剪切板，分别是 0、1、2、...、9、a、“、＋。<code>:reg</code>：查看各个剪切板里的内容。<code>y</code>，<code>p</code>默认使用 &quot;剪切板中的内容。
<code>&quot;[n]y</code>：复制到剪切板<code>n</code>中。<code>&quot;[n]p</code>：粘贴剪切板<code>n</code>中的内容。</p><p><strong>查看是否支持系统剪切板：</strong></p><pre><code class="language-shell">vim --version | grep &quot;clipboard&quot;
</code></pre><p>观看输出中，<code>clipboard</code>前面是<code>+</code>还是<code>-</code>。若是<code>-</code>，则说明不支持系统剪切板。
<code>+</code>号剪切板比较特殊，是<strong>系统剪切板</strong>，用于与系统其他应用互动：</p><ul><li><code>&quot;+y</code>，将内容复制到系统剪切板，<code>ctrl＋v</code>将其粘贴到其他应用中，比如<code>vs code</code>。</li><li><code>&quot;+p</code>，将其他应用中复制的内容，粘贴到vim中。</li></ul><h4>可视模式</h4><p><code>v</code>：进入可视模式。<code>V</code>：进入行选择模式。<code>Crtl + v</code>：进入块选择模式。</p><p>进入可视模式后，可以通过之前的移动操作，来进行选择。比如：<code>hjkl</code>：前后左右选择。<code>$</code>：选择到行尾。<code>i&quot;</code>：选择两个引号之间。</p><p>选择后，可以使用</p><ul><li><code>d</code>进行删除/剪切，</li><li><code>y</code>进行复制。</li><li>还可以使用以下很有意思的命令：<ul><li><code>gU</code>：变大写。</li><li><code>gu</code>：变小写。</li><li><code>J</code>：把所有的行连接起来（变成一行）。</li><li><code>&lt;</code> 或 <code>&gt;</code>：左右缩进。</li><li><code>=</code> ：自动缩进 。</li></ul></li></ul><h4>格式化</h4><p><code>=</code>：调整格式化缩进。<code>gg=G</code>：全文代码格式化。</p><ul><li><code>gg</code>，到文章开头</li><li><code>=</code>，调整格式</li><li><code>G</code>，到文章结尾。</li></ul><h4>自动补全</h4><p>编辑模式下<code>Ctrl + n/p</code>出现提示，此时会出现补全的选项。按住<code>Ctrl</code>不放，用<code>n</code>和<code>p</code>来遍历提示选项，到达期待的选项后，无需其他操作，继续输入即可。</p><h4>撤销</h4><ul><li><code>u</code>：撤销前一个动作</li><li><code>U</code>：撤销当前行的一系列动作</li><li><code>CTRL-R</code>：Redo，意思就是我又不想撤销了。</li></ul><h4>查找替换</h4><ul><li><code>/</code>： 查找，此时Terminal左下角会出现<code>/</code>，在后面输入想要查找的内容，回车即可。</li><li><code>?</code>：反向查找，同样道理，左下角会出现<code>?</code>。</li><li><code>/[search]\c</code>：忽略大小写。比如：<code>/test\c</code>，查找test，忽略大小写</li><li><code>n</code>： 下一个匹配</li><li><code>N</code>： 前一个匹配</li></ul><p>命令模式下：</p><ul><li><code>s/old/new/</code>：用<code>new</code>替换<code>old</code></li><li><code>s/old/new/g</code>：全局替换</li><li><code>set hlsearch</code>：<strong>高亮</strong>搜索结果</li></ul><h4>宏录制</h4><p><code>qa</code> 操作序列 <code>q</code>, <code>@a</code>, <code>@@</code></p><ul><li><code>qa</code> 把你的操作记录在寄存器 <code>a。</code></li><li>于是 <code>@a</code> 会replay被录制的宏。</li><li><code>@@</code> 是一个快捷键用来replay最新录制的宏。</li></ul><h2>命令</h2><ul><li><code>:w</code>：保存修改</li><li><code>:wq</code>：保存修改并退出</li><li><code>ZZ</code>：保存修改并退出</li><li><code>q!</code>：不保存修改，强制退出</li><li><code>e!</code>：不保存修改，强制重新打开当前文件</li></ul><blockquote><p>大家可以看到，<code>!</code>的作用便在于，强制。除此以外，他还有另一个很强势的功能，就是执行shell命令。具体信息，大家可以详细阅读下一节。</p></blockquote><ul><li><code>.</code>：重复执行前一个命令。这个命令很灵活、实用，建议多多尝试。</li><li><code>:help [command]</code>：查看某命令的help此外，在命令行中执行如下命令，便可进入vim的教程。</li></ul><pre><code class="language-shell">vimtutor
</code></pre><h2>外部命令</h2><p>这是<code>vim</code>的一个很神奇的功能，在编辑的时候可以与外部文本互动，甚至执行一些<code>shell</code>命令。</p><ul><li><p><code>:w [file-name]</code>：将当前内容输出到指定文件中</p></li><li><p><code>:r [file-name]</code>：将另外一个文件的内容输出到当前位置</p></li><li><p><code>:e filename</code>：vim下打开指定文本</p></li><li><p><code>ctrl+w, s</code>：水平拆分窗口</p></li><li><p><code>ctrl+w, v</code>：垂直拆分窗口</p></li><li><p><code>ctrl+w, ARROW(h,j,k,l或方向键)</code>：在窗口间切换光标。</p></li><li><p><code>ctrl+w, w</code>：在窗口间切换光标。</p></li><li><p><code>:qa</code>：关闭所有窗口。</p></li><li><p><code>:saveas</code>：另存为。</p></li><li><p><code>:n/bn/bp</code>：在打开的多个文件间切换。</p></li><li><p><code>:![command]</code>：vim下执行某shell命令。</p></li><li><p>比如，<code>:!ls</code>，便会暂时切换到shell下，输出当前目录的文件名。此时输入回车，便可退回当前<code>vim</code>编辑的文件中。</p></li></ul><p>如果你觉得这种输入命令的方式还不够过瘾，<code>vim</code>还提供了保留当前工作现场，直接进入shell的方式。这种命令一个典型的工作场景是，如我们编辑了一个文件，但是发现无法保存（没有写权限），此时可以先进入到shell下，执行类似<code>chmod u+w [filename]</code>，的命令，为当前用户获取该文件的写权限，然后再回到 vim 保存刚刚的修改。 有如下两种方法：</p><ol><li><code>:shell</code> 或 <code>:sh</code>，当退出当前 shell 时（比如<code>exit</code>），就会回到 vim。</li><li><code>ctr-z</code> 进入 shell，<code>fg</code> 退回 vim。</li></ol><h1>Config</h1><p>这部分主要是一些vim的config。可以直接命令模式输入，也可以保存到<code>~/.vimrc</code>中，便可每次打开<code>vim</code>自动应用。(其中一些命令是互相冲突的，请自行选择有用的命令)。</p><pre><code class="language-shell">syntax on # 开启语法高亮

set nu[mber] # 显示行号
set nonu[mber] # 隐藏行号

set cursorline # 高亮当前行
set ruler # 显示光标位置信息
set noruler # 隐藏光标位置信息

set hlsearch # 高亮匹配
set nohlsearch # 取消高亮匹配
nohlsearch # 临时取消高亮（只取消一次查询的高亮）
set incsearch # 在输入字符串过程中显示匹配点
set nowrapscan # 找到文尾后停止查找
set wrapscan # 恢复为到文尾后自动从头开始
set ic/ignorecase) # 忽略大小写
set noic/noignorecase # 区分大小写&lt;/pre&gt;
</code></pre><h1>VIM思想</h1><p>这部分主要是一些我在使用<code>vim</code>过程中的一些思考和感悟，试图尽力阐述出来。如果大家能有一些思考和收获，说明我的思考是有意义的。如果大家有不同见解，十分欢迎拍砖交流。</p><h4>Why Normal</h4><ul><li>为什么vim下，要放弃人们习惯的插入模式，使用命令模式呢？仔细想一想，其实原因很简单：在没有鼠标的年代，人们只能依靠键盘来移动光标，修改文本。</li><li>为什么现在有了鼠标，我们还要用正常模式呢?<ol><li>工作内容覆盖。我们每个人都认为，工程师的工作，是写代码。然而，其实我们主要的工作，是读，或者说，理解代码。经调查，工程师日常工作中，读：写代码的比例，为10：1(参考《Clean Code》一书)。所以默认的普通模式，主要满足占比重更大的”读“；遇到需要修改的时候，再进入编辑模式。</li><li>大量快捷键。相信每个人，都最起码知道一组快捷键：<code>ctrl-c/v</code>，也就是我们熟悉的copy &amp; paste. 如果你平时注重效率，养成了快捷键的习惯，还可能知道一些诸如<code>ctrl-a/x/s/w</code>等。不知你注意到没有，如刚刚列举的很多快捷键，都由 <code>特殊的命令符+字母</code>构成。因为在此时，键盘上的大多数按键，都是可以<strong>输入到文本中的字符</strong>。而在<code>vim</code>的正常模式下面，无法直接向文件中输入这些字符，相当于<strong>不用按<code>ctrl</code>等特殊的命令符</strong>，直接可以把这些按键，用作命令的快捷键。</li></ol></li></ul><h4>合理的快捷键</h4><ul><li>vim中的快捷键，布局非常合理。根据使用频繁程度，调整距离手边的距离。比如，最基础的移动操作，放在手边的<code>HJKL</code>。虽然移动将手移动到键盘上的方向键，并未真正的浪费多少时间，但是其对思维的打断，其实非常影响效率。</li><li>快捷键的设置，也是非常合理，结合了单词的意义、读音，非常便于记忆。比如：<ul><li><code>d</code>	delete</li><li><code>c</code>	change</li><li><code>w</code>	word</li><li><code>e</code>	end</li><li><code>b</code>	back</li><li><code>I</code>	edit</li><li><code>f</code>	find</li><li><code>r</code>	replace</li></ul></li></ul><h4>精细化，多维度命令</h4><p>快捷键应有尽有，各个维度移动，都切合使用者思维，几乎可以做到”指哪儿打哪儿“。
比如，移动、删除、复制、等等操作，都可以结合精细化的位置，根据符合人类思维的不同维度，进行操作。
比如，字符，单词，行，文章，屏幕，匹配（位置、文字、符号），以及类似书签的Mark等。</p><h4>原子、组合命令</h4><p><code>vim</code>的大部分快捷键，都是原子操作，并通过与范围结合，排列组合，灵活多变，完成各种强大的功能。这也与<code>unix</code>的主要思想契合：每个命令做好，且只做好同一件事。
与此同时，通过用数字和宏，代替无意义的重复。
此外，对一些常用操作，提供了现成的宏，方便操作。比如，<code>dd</code>，是删除整行，同时也可以直接用<code>D</code>来完成。<code>I</code>，<code>A</code>等，也是类似道理。</p><h4>外部命令</h4><p>类似栈的思路，可以放下当前操作，保存现场，然后进入另一个操作。当操作完成后，回到当前现场。</p><h4>思维模式</h4><p><code>vim</code>的快捷键，或者说命令，不仅很符合我们的思维，而且还能在很大程度上扩展我们的思维。
拿编辑代码时最多的操作，移动光标来说。原来我们的移动，基本就是通过键盘的方向键，上下左右，或者通过鼠标，移动到想要去的位置。而在vim中，你会发现，光标除了上下左右，还可以移动到词首，词尾，句首，句尾，行首，行尾，页面首部，页面中部，页面尾部，文档首部，文档尾部，文档任意一行，甚至还可以移动到某个指定字母，某个tag，匹配大、中、小括号。度过最初的不适应后，通过刻意练习和日常使用，肌肉形成记忆，便无需刻意回想是用什么命令，而是潜意识完成操作。掌握了这些命令后，当你使用原来的编辑器时，也会去寻找这些快捷键。这就不仅仅是使用vim时候提供效率了，而是通过提高编辑操作的意识、思想，提高了整体的工作效率。</p><p>使用vim一段时间后，我在其他工具中进行编辑时，编再也无法忍受，一个一个自读地移动光标。于是也会主动去找单词、行级别移动的快捷键。</p><ul><li>Mac系统<ul><li><code>cmd + ←/→</code>	移动到：当前行首/尾部</li><li><code>alt + ←/→</code>	移动到：当前单词首/尾部</li></ul></li><li>iterm：<ul><li><code>ctrl + f/b</code>	前进/后退一个字符</li><li><code>Esc + f/b</code>	前进/后退一个单词</li><li><code>ctrl + a/e</code>	行首/行尾</li><li><code>ctrl + h/d</code>	删除光标前/后一个字符</li><li><code>ctrl + w</code>	删除光标前一个单词</li><li><code>ctrl + k/u</code>	删除光标前/后所有内容</li><li><code>ctrl + y</code>	粘贴之前删除的内容</li></ul></li></ul><h1>后记</h1><p>这篇文章到这里也就结束了，洋洋洒洒写了这么多，一次读下来就接受，很难；仅仅通过阅读就掌握，更难。想要真正用熟<code>vim</code>，掌握思想，需要后续更多思考、实践。但是相信我，这些付出，一定是值得的。因为它不仅能让你掌握一个开发利器，更能带给你很有价值的思想。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[关于GTD的思考]]></title>
            <link>https://wolffn.github.io/blog/2018/02/16/关于GTD的思考</link>
            <guid>关于GTD的思考</guid>
            <pubDate>Fri, 16 Feb 2018 00:00:00 GMT</pubDate>
            <description><![CDATA[WHY GTD]]></description>
            <content:encoded><![CDATA[<h2>WHY GTD</h2><p>专注目标不是那么容易做到的，需要学会<strong>分离与当前无关的任务/问题</strong>，工作中经常会碰到的问题可以首先寻找简单可用可靠的方案，并将心中的疑虑记录下来，<strong>集中成一个列表</strong>，工作之外翻翻书，系统思考和学习，而不会因为这个问题而叉开思路对相关的内容研究一番。总之，<strong>专注当前的任务，把新问题记录下来，回头再专心攻克。</strong>  </p><p>用自己最熟悉的工具（我用notes，或者纸笔，以后可能尝试Bear），把待办工作列表（今天要做什么）记录下来，很重要的一点是记录分解后的小目标（分解任务也是一个很重要的能力）。  </p><p>上述关于做事习惯的思考，便是<code>GTD</code>相关内容。所以本文主要关注如何做GTD。</p><h2>稍后读（摘录）</h2><p>稍后读可以算是喜欢收集信息、阅读的同学们都在用的工具了。在使用 Pocket（收趣） 时，我发现了一个特殊的需求和一种特殊的体验。</p><p>这个特殊的需求是：对于我这样的人来说，稍后读服务中会存有一些软件教程类文章，它们操作性较强，不适合纯粹阅读，而是需要我们抽出时间，对照着文章中的步骤学习和执行。这种文章，我需要把它们放在任务管理软件中。</p><p>特殊的体验是：通过 Pocket 中内置的 Evernote 动作，我们可以带着 Pocket 中的标签，发送全文到 Evernote。这个发送的过程不需要特殊界面，也不需要跳转到 Evernote 的应用，它通过 Pocket 这个服务与 Evernote 这个服务之间的联接来实现。在 Pocket 中选择「发送」之后就可以继续阅读剩下的文章，而当我们打开 Evernote 并同步，就能看到这篇发送过去的文章。  </p><p>这种稍后-稍后读的方式，无疑也是<code>GTD</code>的一种形式。</p><h2>GTD</h2><blockquote><p>这部分主要是我阅读<a href="https://sspai.com/article/39996?series_id=1">少数派专栏</a>时的笔记。推荐阅读作者原文。当然，我只记录免费部分。</p></blockquote><p><img src="/img/blog/GTD/GTD.jpg" alt="GTD"/>
上图便是GTD德五个步骤：</p><blockquote><p>「收集」「处理」「整理」「回顾」「执行」</p></blockquote><h2>收集（Capture）</h2><ol><li>做法：只要想到，就记下来。</li><li>目的：把脑子里的事情腾出来。</li><li>不应该脑子里一直存着一些悬而未决的事去做当下的工作</li><li>先找到一个线头，然后顺着联想的线去拽这个线头，就能拉出一大团杂事。</li><li>收件箱随后要清空，不要在收件箱里积攒任务。下一次做收集时，收件箱不应该存在之前看过的任务。</li><li>将不知该如何分类的任务，放到一个单独的列表，命名为「杂项」，或「小事」等</li></ol><h2>厘清（Clarify）</h2><ol><li>目的：把收件箱内的任务明晰化，分清哪些是可行的任务，哪些是不可行的想法。</li><li>效果：收件箱里就会只剩下那些「不能马上做的可行任务」，这些任务，就需要正式进入任务管理系统，来整理分类</li><li>孵化：目前不需要，未知的未来也许会做。比如，“学习一门语言”。不应该保留。原因如下：<ol><li>首先，任务管理系统里应该放那些有完成日期的并且可执行的任务。</li><li>其次，大多数任务管理软件，会在项目后面显示未完成任务数，这个是一个压力源。</li></ol></li><li>标准：让任何人在看到这个任务后都知道这么做，可以马上执行：时机（什么时候）、重点（做什么）、执行方式（类似URL）</li></ol><h2>整理（Organize）</h2><ol><li>列表：让每个任务都有所属</li><li>标签：标注一个任务的执行时的情境：在哪里做、优先级、分配给谁<br/><img src="/img/blog/GTD/list.png" alt="GTD"/><br/><img src="/img/blog/GTD/tag.png" alt="GTD"/>  </li></ol><h2>回顾（Reflect）</h2><ol><li>目的：保障系统的有效性，不堆积无效和不能处理的任务。</li><li>当下回顾：日常行为。定期回顾：最少是每周回顾一次
<img src="/img/blog/GTD/reflect.png" alt="GTD"/></li></ol><h2>执行（Engage）</h2><p>「出行前」、「不到 5 分钟行动」</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CSS居中的各种实现方式]]></title>
            <link>https://wolffn.github.io/blog/2017/11/15/CSS居中的各种实现方式</link>
            <guid>CSS居中的各种实现方式</guid>
            <pubDate>Wed, 15 Nov 2017 00:00:00 GMT</pubDate>
            <description><![CDATA[CSS中如何完美做到居中，一直是令前端工程师头疼的问题。最近读到CSS-TRICKS中的一篇帖子，将居中问题的解决方案策略化。感觉收获很大，翻译过来供大家交流学习。]]></description>
            <content:encoded><![CDATA[<p><em>CSS中如何完美做到居中，一直是令前端工程师头疼的问题。最近读到<a href="https://css-tricks.com/">CSS-TRICKS</a>中的一篇帖子，将居中问题的解决方案策略化。感觉收获很大，翻译过来供大家交流学习。</em>
当我们书写CSS时，让元素居中，是抱怨的爆发点之一：为什么会这么难？<br/>
<!-- -->我认为问题的关键，不在于怎么做，而在于我们如何从诸多居中方法中选择出适应当前情景的。<br/>
<!-- -->所以接下来，让我们一起创建一颗决策树，希望可以让居中变得简单。</p><h2>水平居中</h2><h3>行内元素</h3><p>我们可以通过对其父级块元素做如下处理来使行内元素居中。适用于<code>inline</code>,<code>inline-block</code>,<code>inline-table</code>,<code>inline-flex</code>等。</p><pre><code class="language-css">.center-children{
  text-align: center;
}
</code></pre><blockquote><p>示例：<a href="http://codepen.io/chriscoyier/pen/HulzB">传送门</a>  </p></blockquote><h3>块级元素</h3><p>我们可以通过将一个块级元素的<code>margin-left</code>和<code>margin-right</code>同时设置为<code>auto</code>来使其居中。<em>（注意：此时元素必须定义有<code>width</code>，否则将填满宽度，谈不上水平居中。）</em>通常由以下简写来定义：</p><pre><code class="language-css">.center-me {
  margin: 0 auto;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/eszon">传送门</a></p></blockquote><h3>多个块级元素</h3><p>当同一行中有两个或以上块级元素需要居中时，我们不得不通过改变<code>display</code>的类型来实现。下面的例子分别将<code>display</code>设置为<code>inline-block</code>以及<code>flexbox</code>的例子。</p><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/ebing">传送门</a>  </p></blockquote><p>当你指的是多个位于同一列上的块级元素时，将<code>margin</code>设为<code>auto</code>的技术依旧生效。  </p><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/haCGt">传送门</a>  </p></blockquote><h2>垂直居中</h2><p>在CSS中做到垂直居中，我们需要稍微狡猾一点。</p><h3>行内元素</h3><h4>单行</h4><p>有时行内元素或文本能够做到垂直居中，仅仅是因为元素上、下的<code>padding</code>相等。</p><pre><code class="language-css">.link {
  padding-top: 30px;
  padding-bottom: 30px;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/ldcwq">传送门</a>  </p></blockquote><p>在某些情况当<code>padding</code>不适用，并且文字不会换行时，有一个技巧：当<code>line-height</code>与<code>height</code>相等时，文字垂直居中。</p><pre><code class="language-css">.center-text-trick {
  height: 100px;
  line-height: 100px;
  white-space: nowrap;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/LxHmK">传送门</a>  </p></blockquote><h4>多行</h4><p>上下<code>padding</code>相等依旧可以解决这个问题。但当此方法不生效时，可能是元素或文本处于<code>table cell</code>中，要么是<code>html</code>语义中的<code>table</code>，要么是<code>CSS</code>中的设置。这种情况下，我们使用<code>vertical-align</code>来完成垂直居中。注意：此为特殊用法，<code>vertical-align</code>平时用来处理一行中的元素如何排列。</p><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/ekoFx">传送门</a>  </p></blockquote><p>如果类似<code>table</code>的那些无效时，也许我们应该尝试下<code>flexbox</code>。 在<code>flex</code>中，一个子元素可以轻易地在父元素中居中。</p><pre><code class="language-css">flex-center-vertically {
  display: flex;
  justify-content: center;
  flex-direction: column;
  height: 400px;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/uHygv">传送门</a></p></blockquote><p>记住，这种做法仅在父级元素高度固定时(px, %等)才有效。
如果上述两种做法都无效，那么我们可以采用“幽灵元素”技术。在这种做法中，一个伪元素占据父元素的全部高度，然后文本在其中垂直居中。</p><pre><code class="language-css">.ghost-center {
  position: relative;
}
.ghost-center::before {
  content: &quot; &quot;;
  display: inline-block;
  height: 100%;
  width: 1%;
  vertical-align: middle;
}
.ghost-center p {
  display: inline-block;
  vertical-align: middle;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/ofwgD">传送门</a>  </p></blockquote><h3>块级元素</h3><h4>高度已知时</h4><p>由于诸多原因，很多情况我们无法得知元素的高度，比如：当宽度变化时，文字的重绘会改变高度；文字样式的变化可能改变高度；文字数量的变化可能改变高度；宽高比固定的元素，比如图片，在改变大小时也会改变高度，等等。
但当我们知道高度时，可以按照如下方法实现垂直居中：</p><pre><code class="language-css">.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  height: 100px;
  margin-top: -50px; /* account for padding and border if not using box-sizing: border-box; */
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/HiydJ">传送门</a>  </p></blockquote><h4>高度未知时</h4><p>在这种情况下，我们仍然可以实现垂直居中：将元素下移父级元素的50%，再上移自身高度的50%。</p><pre><code class="language-css">.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/lpema">传送门</a>  </p></blockquote><h4>可以使用<code>flexbox</code>时</h4><p>不算什么大的惊喜，在<code>flexbox</code>中，这可容易多了。</p><pre><code class="language-css">.parent {
  display: flex;
  flex-direction: column;
  justify-content: center;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/FqDyi">传送门</a>  </p></blockquote><h2>同时水平和垂直居中</h2><p>我们可以通过结合使用前面讲述的技巧来实现将元素完美居中。主要有以下三种情况：</p><h3>元素宽高固定时</h3><p>此时可以使用绝对定位将元素置于父元素(50%，50%)的位置，之后再通过将<code>margin</code>设置为负值。这种方法拥有广泛的浏览器支持。</p><pre><code class="language-css">.parent {
  position: relative;
}

.child {
  width: 300px;
  height: 100px;
  padding: 20px;

  position: absolute;
  top: 50%;
  left: 50%;

  margin: -70px 0 0 -170px;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/JGofm">传送门</a>  </p></blockquote><h3>元素宽高不固定时</h3><p>当宽高不固定时，我们可以使用<code>transform</code>属性来实现将元素在两个方向同时移动50%。该宽度基于当前元素的宽度。</p><pre><code class="language-css">.parent {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/lgFiq">传送门</a>  </p></blockquote><h3>可以使用<code>flexbox</code>时</h3><p>此时我们需要使用两个居中属性：</p><pre><code class="language-css">.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
</code></pre><blockquote><p>示例: <a href="http://codepen.io/chriscoyier/pen/msItD">传送门</a>  </p></blockquote><h3>补充额外一种兼容性很好的方法</h3><pre><code class="language-css">.Absolute-Center {
  margin: auto;
  position: absolute;
  top: 0; left: 0; bottom: 0; right: 0;
}
</code></pre><h2>结论</h2><p>我们完全可以在CSS中实现居中。</p><p><em>译自：<a href="https://css-tricks.com/centering-css-complete-guide/">https://css-tricks.com/centering-css-complete-guide/</a></em></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Chrome Dev Tools---[基础篇]]]></title>
            <link>https://wolffn.github.io/blog/2017/11/15/Chrome-Dev-Tools-基础篇</link>
            <guid>Chrome Dev Tools---[基础篇]</guid>
            <pubDate>Wed, 15 Nov 2017 00:00:00 GMT</pubDate>
            <description><![CDATA[Chrome Dev Tools 是每一位前端工程师开发调试的必备利器，称之为FE的瑞士军刀也毫不为过。然而，每每当发现一些自己不知道的用法时，我们经常会觉得，自己只是掌握了其强大功能的九牛一毛。为了能够让她发挥出最大功效，首先，我们应当了解她更多的使用方法；然后，在开发中合适的场景下，刻意练习使用；最后，熟练掌握那些之前不了解的功能，并为我所为用，最大提升效率。]]></description>
            <content:encoded><![CDATA[<p>Chrome Dev Tools 是每一位前端工程师开发调试的必备利器，称之为FE的瑞士军刀也毫不为过。然而，每每当发现一些自己不知道的用法时，我们经常会觉得，自己只是掌握了其强大功能的九牛一毛。为了能够让她发挥出最大功效，首先，我们应当了解她更多的使用方法；然后，在开发中合适的场景下，刻意练习使用；最后，熟练掌握那些之前不了解的功能，并为我所为用，最大提升效率。</p><blockquote><p>本文翻译自<a href="https://developers.google.com/web/tools/chrome-devtools">谷歌官方文档</a>，主要介绍了Elements, Console, Sources, Network四个Tab页面下的功能。敬请期待<code>Chrome Dev Tools 性能篇</code></p></blockquote><h2>Elements</h2><ul><li><p>进入：</p><ol><li><code>Cmd + Alt + c</code> inspect，点击想观察的节点</li><li>console中<code>inspect(DOM)</code>，<code>DOM</code>为想观察的节点。</li></ol></li><li><p>遍历节点：</p><ol><li>鼠标点击</li><li>在DOM节点中，上下箭头跳转，向右箭头，展开折叠的节点。向左箭头，折叠打开的节点。</li></ol></li><li><p>编辑节点
<code>F2</code> -&gt; Edit as HTML. <code>ctrl+enter</code>保存更改，<code>Esc</code>退出更改，不保存.</p></li><li><p>编辑 DOM 节点名称或属性</p><ol><li>直接在节点名或属性上双击</li><li>选中突出节点，<code>Enter</code>,然后<code>Tab</code>选择.</li><li>右键,<code>Edit/Add Attribute</code>.</li></ol></li><li><p>点击并拖动,可以移动DOM节点.</p></li><li><p>右键-&gt;<code>Scroll into view</code>,滚动页面使节点在视口中显示.</p></li><li><p>断点调试</p><ol><li>右键节点-&gt;<code>break on</code>，可以对该节点的子树修改、属性修改、节点移除三种事件添加断点</li><li>右侧<code>DOM Breakpoints</code>,管理<strong>DOM断点</strong>.</li><li>Event Listener<ol><li>Ancestors 显示祖先节点的事件侦听器。</li><li>每个Event Listener包含两个属性<ul><li>handler, <code>右键</code> -&gt; <code>Show Function Definition</code></li><li>useCapture, addEventListener函数中<code>useCapture</code>的值(bool).</li><li>Framework listeners, 框架事件监听器. </li></ul></li></ol></li></ol></li><li><p><strong>Styles</strong>，位于面板左侧，主要是样式相关内容</p><ul><li>页面底端的Computed 可以编辑，修改。</li><li>点击<code>Styles</code>中的文件名-&gt;跳转到Source-&gt;右键，Local Modifications.</li><li><code>Inherited from &lt;NODE&gt;</code>,点击<code>&lt;NODE&gt;</code>可以跳转到该DOM节点。</li><li>灰色条目不是已定义规则，而是在运行时计算的规则。</li><li>鼠标悬停在 CSS 选择器上可以查看受该选择器影响的所有元素。</li><li>点击右上角<code>.cls</code>,可以查看、增加、删除class。</li><li>点击(并长按)右上角<code>+</code>按钮，(选择要向哪一个样式表)添加一个新的 CSS 规则。</li><li>点击右上角<code>:hov</code>，或在元素上点击右键，启用/删除伪类。</li><li>点击css属性进行修改，tab跳转；Alt/ /Shift/Shift+Fn + 上/下，增减0.1,1,10,100。</li><li>鼠标悬停到样式表上面，此时右下角出现三个点，移动过去，此时有<code>color</code>,<code>background-color</code>等快捷方式。</li><li>点击<code>color</code>声明左侧带颜色的小正方形，打开<code>color-picker</code>。</li></ul></li></ul><h2>Console</h2><ul><li>进入: <code>Cmd + Alt + J</code></li><li>编辑时，输入<code>Shift + Enter</code>实现换行，而不会直接运行。</li><li>Settings -&gt; General -&gt; Console -&gt; <ul><li>Hide network messages/ Log XMLHttpRequests/ Preserve log / Enable custom formatters</li><li>Show timestamps 展开消息堆叠.</li></ul></li></ul><h4>Console API</h4><ul><li><p>Ctrl + L/ <code>clear()</code> /<code>console.clear()</code> 清空console.</p></li><li><p>右键 -&gt; Save As 保存console输出.</p></li><li><p>日志组按组输出,可嵌套:</p><pre><code class="language-javascript">console.group(&quot;Group Name&quot;)
console.groupCollapsed(&quot;Group Name&quot;)//默认折叠
console.groupEnd()
</code></pre></li><li><p>计时器,时间戳,<em>在Timeline上有标注</em></p><pre><code class="language-javascript">console.time(&quot;name&quot;);
console.timeEnd(&quot;name&quot;);
// 向Timeline添加一个标记
console.timeStamp(&quot;Adding result&quot;);
</code></pre></li><li><p>断言,在console中可跳转到代码对应位置.</p><pre><code class="language-javascript">console.assert(a &lt; 500, &quot;a &gt; 500!&quot;);
</code></pre></li><li><p>堆栈追踪&amp;&amp;错误处理</p><pre><code class="language-javascript">// 追踪堆栈
try {
    // some code here
} cache(e) {
    console.log(e.stack);
}
// 打印跟踪调用栈
console.trace();
// 处理运行时异常
window.onerror = function(message, url, line){
    console.log(&quot;window.onerror was invoked with message = &quot; + message + &quot;, url = &quot; + url + &quot;, line = &quot; + line);
}
</code></pre></li><li><p>字符串替换 <code>%s %d %f %o(DOM节点) %O(js对象) %c 样式</code>。不过有了ES6以后，推荐使用更加方便、灵活的模板字符串</p></li><li><p>添加cpu配置文件.将会添加到<code>Profiles</code>面板中</p><pre><code class="language-javascript">console.profile(&quot;label&quot;);
console.profileEnd();
</code></pre></li><li><p>其他特殊用法</p><pre><code class="language-javascript">// DOM元素格式化为JS对象
console.dir(document.body);
// 输出object子级元素xml
console.dirxml(object);

// 将Object,Array输出
console.table([{a:1, b:2, c:3}, {a:&quot;foo&quot;, b:false, c:undefined}]);
console.table([[1,2,3], [2,3,4]]);
console.table(family, [&quot;firstName&quot;, &quot;lastName&quot;, &quot;age&quot;]);

// 记录相同字符串传入的次数(多用于统计函数调用次数)
console.count(&quot;Login called for user &quot; + user);
</code></pre></li></ul><h4>Command Line API</h4><ul><li><p>↑ / ↓切换查看表达式 </p></li><li><p>选择元素</p><pre><code class="language-javascript">$(&#x27;code&#x27;) // document.querySelector()
$$(&#x27;figure&#x27;) // document.querySelectorAll()
$x(&#x27;html/body/p&#x27;) // 返回与指定xpath匹配的数组元素
$0 - 4 // 返回最近访问过的5个元素,$0为最新的一个
</code></pre></li><li><p>监听事件, 查看时间监听器(<code>Elements</code>-&gt;<code>Event Listener</code>中也可以查看)</p><pre><code class="language-javascript">monitorEvents(document.body, &quot;click&quot;); // 监听事件
unmonitorEvents(document.body); // 取消监听
getEventListeners(document); // 返回在指定对象上注册的事件侦听器
</code></pre></li><li><p>复制:将指定对象的字符串表示形式复制到剪贴板.</p><pre><code class="language-javascript">copy(object);
copy($0);
</code></pre></li><li><p>调试函数</p><pre><code class="language-javascript">debug(fn); // 调用fn时开始调试
undebug(fn); // 停止调试

monitor(function); // console中将输出函数调用,以及传入的参数
unmonitor(function); // 停止监控
</code></pre></li><li><p>在<code>Elements</code>中打开指定元素/对象/函数.</p><pre><code class="language-javascript">inspect(DOM);
inspect(object/function);
</code></pre></li><li><p>查看对象</p><pre><code class="language-javascript">keys(object);
values(object);
</code></pre></li></ul><h2>Sources</h2><ul><li>添加断点<ul><li>添加<code>Event</code>断点:
<code>Source标签</code>-&gt;右侧<code>Event Listener Breakpoints </code>-&gt;<code>Mouse</code>-&gt;<code>click</code></li><li><code>DOM</code>断点.Elements 面板中，对DOM节点右键，Break On...</li><li><code>XHR</code>断点</li><li>异常断点:右上角<code>Pause on exceptions</code></li><li>条件断点</li></ul><pre><code class="language-javascript">//  当DOM元素满足某个条件进行断点，同时查看这个元素
elem.hasAttribute(&#x27;class&#x27;) &amp;&amp; inspect(elem);
</code></pre></li><li>在编辑器中行首右键,<code>continue to here</code></li><li>检测变量值<ul><li><code>Watch</code>-&gt;<code>+</code>,添加希望检测的表达式,比如,a,typeof a</li><li><code>Scope</code>窗格,在脚本暂停时,会显示当前变量</li></ul></li><li>log变量值<ul><li>右键 -&gt; <code>Add logpoint</code></li></ul></li><li>右上角<code>Deactivate breakpoints</code>,启动/忽略全部断点</li><li><code>Call Stack</code>调用堆栈<ul><li>在<code>Call Stack</code>中右键,<code>Restart Frame</code></li><li><code>Async</code>,提高完整的异步函数调用堆栈的可视性</li><li>使用非匿名函数,提高堆栈可读性</li></ul></li><li>将第三方脚本添加入黑箱:<ul><li>在已打开的文件中,右键-&gt;<code>Blackbox Script</code></li><li>在<code>Call Stack</code>中,右键-&gt;<code>Blackbox Script</code></li><li><code>Settings</code>-&gt;<code>Blockboxing</code>-&gt;<code>add pattern</code>,下拉菜单中,<code>Blackbox</code>黑箱,<code>Disabled</code>阻止执行</li></ul></li><li>实时编辑:编辑器中修改代码-&gt;<code>Cmd + s</code>，继续运行代码</li><li><code>Threads</code>,切换线程</li><li><code>Source Map</code>, <code>Settings</code>中开启</li><li><code>Snippets</code> 编写代码，运行结果输出到<code>console</code></li></ul><h2>Network</h2><ul><li>面板中，蓝线标志<code>DOMContentLoaded</code>事件，红线标志<code>load</code>事件。</li><li><code>Http1.0/1.1</code>下,<code>chrome</code>最多支持对同一个<code>domain</code>6个<code>TCP</code>请求</li><li>Shift + 光标移动到request上面，此时绿色标志该请求的发起者，红色标志该请求的依赖项。</li><li>摄像机按钮，<code>Capture Screenshots</code>，再次刷新页面时，可以在时间轴上方看到对应屏幕状态。</li><li><code>disable cache</code>,<code>throttle</code>,<code>Offline</code>,<code>hide data urls</code></li><li>右键-&gt;<code>clear browser cache</code></li><li>右键表格header -&gt; 添加/移除显示列</li><li><code>header</code>:<code>Use large request rows</code>,<code>Show overview</code></li><li>右键request-&gt;<code>copy response</code>-&gt;console中<code>copy({})</code>-&gt;得到格式化的JSON</li><li><ul><li>右键request-&gt;<code>block request</code> 在drawer中,查看被block的request</li></ul></li><li>右键<code>XHR request</code> -&gt; <code>reply XHR</code></li><li><code>Summary</code>: request数量,大小,时间</li><li>Filter<ul><li>空格隔开:并</li><li><code>domain</code>,<code>has-response-header</code>,<code>is</code>(is:running),<code>larger-than</code>,<code>method</code>,<code>mime-type</code>,<code>mixed-content</code>,<code>scheme</code>,<code>set-cookie-domain</code>,<code>set-cookie-name</code>,<code>set-cookie-value</code>,<code>status-code</code></li></ul></li><li>Timing含义:
Queuing: 排队时间.
Stalled: http请求建立到发出去.
Proxy Negotiation、DNS Lookup
Initial Connection/Connecting: 建立链接花费时间。TCP握手移机重试.
SSL: 建立SSL链接花费时间.
Request sent: 发起请求的时间.
Waiting (Time to first byte (TTFB)): 发起请求到接受第一个字节数据.
Content Download: 获取响应数据的时间.</li></ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Mac开发环境配置]]></title>
            <link>https://wolffn.github.io/blog/2017/11/15/Mac开发环境配置</link>
            <guid>Mac开发环境配置</guid>
            <pubDate>Wed, 15 Nov 2017 00:00:00 GMT</pubDate>
            <description><![CDATA[本文主要记录Mac开发环境的设置,以及一些优秀软件,使用技巧,等, 后续还会继续逐渐添加.]]></description>
            <content:encoded><![CDATA[<blockquote><p>本文主要记录Mac开发环境的设置,以及一些优秀软件,使用技巧,等, 后续还会继续逐渐添加.</p></blockquote><blockquote><p>所有的设置,软件以及技巧都追求 在极致简洁和极致效率, 最大可能提升工具效率,以提升生产力. </p></blockquote><blockquote><p>主要作为个人笔记性质,故有些细节略去.如有不解,欢迎留言.如有推荐 or 其他软件问题,欢迎留言探讨.</p></blockquote><blockquote><p>已做分章节处理，移步<a href="https://wolffn.github.io/docs/tools/mac/system">此处</a>阅读。</p></blockquote><h2>参考:</h2><ol><li><a href="http://blog.jobbole.com/63130/">http://blog.jobbole.com/63130/</a></li><li><a href="http://macshuo.com/?p=676">http://macshuo.com/?p=676</a></li><li><a href="https://help.github.com/articles/connecting-to-github-with-ssh/">https://help.github.com/articles/connecting-to-github-with-ssh/</a></li></ol>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Linux-Mac-Shell常用命令]]></title>
            <link>https://wolffn.github.io/blog/2016/08/26/Linux-Mac-Shell常用命令</link>
            <guid>Linux-Mac-Shell常用命令</guid>
            <pubDate>Fri, 26 Aug 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[工欲善其事，必先利其器。无论是做哪一方面开发的程序员，都免不了和shell打交道，不管是基于Linux的服务器、开发机，还是Mac。]]></description>
            <content:encoded><![CDATA[<blockquote><p>工欲善其事，必先利其器。无论是做哪一方面开发的程序员，都免不了和shell打交道，不管是基于Linux的服务器、开发机，还是Mac。</p></blockquote><blockquote><p>本文主要记录一些Shell命令的基本用法，作为参考/查询手册，随时更新、完善。更多技巧以及详细解释将后续以专题形式持续更新。</p></blockquote><h2>命令行操作技巧</h2><h3>光标移动</h3><blockquote><p>注意：Mac系统下Terminal以及Iterm下，使用Alt相关功能，需要单独设置。  </p></blockquote><ol><li><code>ctrl + a</code>   移动至行首</li><li><code>ctrl + e</code>   移动至行尾</li><li><code>alt + f</code>    向后移动一个单词</li><li><code>alt + b</code>    向前移动一个单词</li><li><code>alt + 左键</code>  直接移动到点击位置</li></ol><h3>编辑</h3><ol><li><code>ctrl + k</code>   删除至行尾</li><li><code>ctrl + u</code>   删除至行首</li><li><code>ctrl + w</code>   删除前一个单词</li><li><code>ctrl + y</code>   粘贴删除的内容  </li></ol><p>应用示例：输入命令时，发现忘记在最前面输入<code>sudo</code>，可进行如下操作：
<code>ctrl + u</code>，输入<code>sudo</code>，<code>ctrl + y</code></p><h3>其他</h3><ol><li><code>ctrl + x + e</code>   x,e依次输入，进入编辑器中编辑命令</li><li><code>alt + .</code>   上一条命令的参数</li></ol><h2>常用命令</h2><ol><li><code>ls</code> 查看当前目录下的文件</li><li><code>cd</code> 进入某目录
<code>cd -</code> 跳转回前一目录
<code>cd ~</code> 进入当前用户个人目录</li><li><code>pwd</code> 输出当前所在路径</li><li><code>mkdir</code> 新建文件夹</li><li><code>touch</code> 新建文件</li><li><code>find</code> 查找文件</li><li><code>ln</code> 建立链接</li><li><code>du</code> 查看目录大小</li><li><code>cal</code> 显示日历</li><li><code>date</code> 显示当前日期、时间</li></ol><h2>文件传输类</h2><ol><li><code>mv</code> 移动文件/重命名</li><li><code>cp [File Name] [Destination]</code> 拷贝文件</li><li><code>cp -R [File Name] [Destination]</code>递归拷贝（主要用于文件夹）</li><li><code>scp</code> 远程拷贝，除了需要在远程地址的目录前加入<code>user@host:</code>形式的地址信息外，命令用法与copy一致</li><li><code>ftp</code> 启动ftp服务。</li></ol><h2>压缩与解压缩</h2><p> <code>tar</code> 打包压缩
<code>-c</code> 归档文件
<code>-x</code> 解压缩文件
<code>-v</code> 显示压缩/解压缩过程
<code>-j</code> bzip2压缩文件
<code>-z</code> gzip压缩文件
<code>-f</code> 使用档名
<code>tar -cvf</code> 只打包，不压缩
<code>tar -zcvf</code> 打包，并用gzip压缩
<code>tar -jcvf</code> 打包，并用bzip2压缩</p><p>解压缩时，只需将上述命令中<code>c</code>换成<code>x</code>即可。</p><h2>系统命令类</h2><ol><li><p><code>whoami</code> 显示当前操作用户</p></li><li><p><code>hostname</code> 显示主机名</p></li><li><p><code>uname</code> 显示系统信息</p></li><li><p><code>top</code> 动态显示当前耗费资源最多进程信息</p></li><li><p><code>ps</code> 显示瞬间进程状态 <code>ps aux</code></p></li><li><p><code>kill</code> 杀死进程（top/ps查看进程id后，<code>kill [id]</code>）</p></li><li><p><code>netstat</code>显示网络状态信息，<code>lsof -i :3000</code> 查看占用 3000 端口的进程</p></li><li><p><code>which [command]</code> 查看命令所在路径
<code>export [VAR]=&quot;xxx&quot;</code>为系统变量赋值
<code>alias [short]=[long]</code> 为命令设定别名</p></li><li><p><code>du -sh *</code> 带有单位显示目录信息</p></li><li><p><code>df</code> 查看磁盘大小
<code> df -h</code> 带有单位显示磁盘信息</p></li><li><p><code>ps</code>是Process Status的缩写，查看系统进程状态。为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用<code>top</code>工具。</p><p><code>ps -ef</code>用标准的格式显示进程，是比较常用的一种命令，后面管道接<code>grep</code>，查看确切进程状态，之后结合<code>kill</code>命令，杀死进程。</p></li></ol><h2>文本操作类</h2><p>这是比较重要的一节，后面会专门写文章介绍这些概念，这里只作为一个目录。</p><ol><li><code>cat</code> 查看文件内容</li><li><code>head</code> 查看文件头部内容
<code>tail</code> 查看文件尾部内容</li><li><code>more/less</code>分页显示文件内容</li><li><code>grep</code> 在文本文件中查找某个字符串</li><li><code>sed</code>管道命令，以行为单位进行处理</li><li><code>awk</code>管道命令，以列为单位进行处理</li><li><code>|</code> 管道</li><li><code>&gt; &gt;&gt;</code> 重定向。其中，<code>&gt;</code> 为覆盖，<code>&gt;&gt;</code> 为追加。</li></ol><h2>包管理(ubuntu)</h2><p>此处主要介绍ubuntu包管理概念，大多数Mac用户使用Brew，原理类似，具体命令参考帮助文档即可。</p><pre><code class="language-bash">sudo apt-get update 更新软件源信息
sudo apt-get upgrade 更新已安装的包
sudo apt-get dist-upgrade 升级系统（慎重！！！）
sudo apt-get install 安装软件
sudo apt-get -f install   修复安装
sudo apt-get remove 删除软件
sudo apt-get remove --purge 删除软件以及配置文件
sudo apt-get autoremove 自动删除（未删除的依赖）
sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包
</code></pre><h2>权限管理</h2><ol><li><code>chmod</code> 更改权限</li><li><code>chown</code> 更改文件的用户及用户组</li></ol><h2>进阶</h2><h3><a href="http://wolffn.github.io/docs/tools/shell/grep">Grep</a></h3><h3><a href="http://wolffn.github.io/docs/tools/shell/awk">AWK</a></h3><h3><a href="http://wolffn.github.io/docs/tools/shell/shell-script">Shell Script</a></h3>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[github+hexo搭建博客过程全纪录]]></title>
            <link>https://wolffn.github.io/blog/2016/01/22/github-hexo搭建博客过程全纪录</link>
            <guid>github+hexo搭建博客过程全纪录</guid>
            <pubDate>Fri, 22 Jan 2016 00:00:00 GMT</pubDate>
            <description><![CDATA[本文记录mac上搭建hexo+github blog的全过程]]></description>
            <content:encoded><![CDATA[<p><em>本文记录mac上搭建hexo+github blog的全过程</em></p><h2>1.准备篇</h2><ul><li>安装git
若已经安装xcode，（在app store下载安装），只需选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。
若未安装，打开terminal，输入以下命令，安装homebrew</li></ul><pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><p>然后通过homebrew安装git</p><pre><code>brew install git
</code></pre><ul><li><p>安装node</p></li><li><p>安装npm</p></li><li><p>注册github
登录官网 <a href="http://github.com/">http://github.com/</a>注册，并在邮箱中<strong>确认注册</strong>。</p></li><li><p>建立github仓库 username.github.io
项目名称必须为username.github.io，username与注册时的用户名<strong>完全相同</strong>，在该项目的setting中，找到GitHub Pages一项，根据提示开启“automatic page generator”</p></li><li><p>上传rsa key 至github</p></li></ul><h2>2.安装Hexo</h2><p>注：以下采用npm安装。如未翻墙，请在每条命令后面加入如下代码：</p><pre><code>--disturl=http://registry.npm.taobao.org/mirrors/node --registry=http://registry.npm.taobao.org
</code></pre><pre><code>npm install hexo -g --save
</code></pre><p>建立目录，初始化hexo</p><pre><code>mkdir blog
cd blog
hexo init
npm install
</code></pre><h2>3.发表文章至github</h2><p>配置_config.yml</p><pre><code>deploy:
    type: git
    repo: git@github.com:username/usernema.github.io.git
    branch: master
</code></pre><p>重中之重：每个冒号之后都要有 <strong> 一个空格 </strong> ，否则后面的步骤会静默失败，这真是让人抓狂。</p><p>发布新文章</p><pre><code>hexo new &quot;title&quot;
</code></pre><p>生成静态页面</p><pre><code>hexo generate
</code></pre><p>启动本地服务器</p><pre><code>hexo server
</code></pre><p>部署至github</p><pre><code>hexo deploy
</code></pre><p>清空缓存</p><pre><code>hexo clean
</code></pre><h2>4.修改主题</h2><ul><li>在github上寻找喜欢的主题，将其目录拷贝到themes目录下。</li><li>修改_config.yml中theme为新主题名称。</li></ul><p>推荐<a href="https://github.com/iissnan/hexo-theme-next">Next主题</a>，<a href="http://theme-next.iissnan.com/getting-started.html">文档</a>。</p><p><strong> 最后建议将blog目录的code同样提交至github，保存。</strong></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Welcome]]></title>
            <link>https://wolffn.github.io/blog/2010/01/01/welcome</link>
            <guid>Welcome</guid>
            <pubDate>Fri, 01 Jan 2010 00:00:00 GMT</pubDate>
            <description><![CDATA[Blog features are powered by the blog plugin. Simply add files to the blog directory. It supports tags as well!]]></description>
            <content:encoded><![CDATA[<p>Blog features are powered by the blog plugin. Simply add files to the <code>blog</code> directory. It supports tags as well!</p><p>Delete the whole directory if you don&#x27;t want the blog features. As simple as that!</p><p>You can write content using <a href="https://github.github.com/gfm/">GitHub-flavored Markdown syntax</a>.</p><h2>Markdown Syntax</h2><p>To serve as an example page when styling markdown based Docusaurus sites.</p><h2>Headers</h2><h1>H1 - Create the best documentation</h1><h2>H2 - Create the best documentation</h2><h3>H3 - Create the best documentation</h3><h4>H4 - Create the best documentation</h4><h5>H5 - Create the best documentation</h5><h6>H6 - Create the best documentation</h6><hr/><h2>Emphasis</h2><p>Emphasis, aka italics, with <em>asterisks</em> or <em>underscores</em>.</p><p>Strong emphasis, aka bold, with <strong>asterisks</strong> or <strong>underscores</strong>.</p><p>Combined emphasis with <strong>asterisks and <em>underscores</em></strong>.</p><p>Strikethrough uses two tildes. <del>Scratch this.</del></p><hr/><h2>Lists</h2><ol><li>First ordered list item</li><li>Another item ⋅⋅<!-- -->*<!-- --> Unordered sub-list.</li><li>Actual numbers don&#x27;t matter, just that it&#x27;s a number ⋅⋅1. Ordered sub-list</li><li>And another item.</li></ol><p>⋅⋅⋅You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we&#x27;ll use three here to also align the raw Markdown).</p><p>⋅⋅⋅To have a line break without a paragraph, you will need to use two trailing spaces.⋅⋅ ⋅⋅⋅Note that this line is separate, but within the same paragraph.⋅⋅ ⋅⋅⋅(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</p><ul><li>Unordered list can use asterisks</li></ul><ul><li>Or minuses</li></ul><ul><li>Or pluses</li></ul><hr/><h2>Links</h2><p><a href="https://www.google.com">I&#x27;m an inline-style link</a></p><p><a href="https://www.google.com" title="Google&#x27;s Homepage">I&#x27;m an inline-style link with title</a></p><p><a href="https://www.mozilla.org">I&#x27;m a reference-style link</a></p><p><a href="http://slashdot.org">You can use numbers for reference-style link definitions</a></p><p>Or leave it empty and use the <a href="http://www.reddit.com">link text itself</a>.</p><p>URLs and URLs in angle brackets will automatically get turned into links. <a href="http://www.example.com">http://www.example.com</a> or <a href="http://www.example.com">http://www.example.com</a> and sometimes example.com (but not on Github, for example).</p><p>Some text to show that the reference links can follow later.</p><hr/><h2>Images</h2><p>Here&#x27;s our logo (hover to see the title text):</p><p>Inline-style: <img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 1"/></p><p>Reference-style: <img src="https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png" alt="alt text" title="Logo Title Text 2"/></p><hr/><h2>Code</h2><pre><code class="language-javascript">var s = &#x27;JavaScript syntax highlighting&#x27;;
alert(s);
</code></pre><pre><code class="language-python">s = &quot;Python syntax highlighting&quot;
print(s)
</code></pre><pre><code>No language indicated, so no syntax highlighting.
But let&#x27;s throw in a &lt;b&gt;tag&lt;/b&gt;.
</code></pre><pre><code class="language-js" metastring="{2}">function highlightMe() {
  console.log(&#x27;This line can be highlighted!&#x27;);
}
</code></pre><hr/><h2>Tables</h2><p>Colons can be used to align columns.</p><table><thead><tr><th>Tables</th><th align="center">Are</th><th align="right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td align="center">right-aligned</td><td align="right">\$1600</td></tr><tr><td>col 2 is</td><td align="center">centered</td><td align="right">\$12</td></tr><tr><td>zebra stripes</td><td align="center">are neat</td><td align="right">\$1</td></tr></tbody></table><p>There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don&#x27;t need to make the raw Markdown line up prettily. You can also use inline Markdown.</p><table><thead><tr><th>Markdown</th><th>Less</th><th>Pretty</th></tr></thead><tbody><tr><td><em>Still</em></td><td><code>renders</code></td><td><strong>nicely</strong></td></tr><tr><td>1</td><td>2</td><td>3</td></tr></tbody></table><hr/><h2>Blockquotes</h2><blockquote><p>Blockquotes are very handy in email to emulate reply text. This line is part of the same quote.</p></blockquote><p>Quote break.</p><blockquote><p>This is a very long line that will still be quoted properly when it wraps. Oh boy let&#x27;s keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can <em>put</em> <strong>Markdown</strong> into a blockquote.</p></blockquote><hr/><h2>Inline HTML</h2><dl><dt>Definition list</dt><dd>Is something people use sometimes.</dd><dt>Markdown in HTML</dt><dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd></dl><hr/><h2>Line Breaks</h2><p>Here&#x27;s a line for us to start with.</p><p>This line is separated from the one above by two newlines, so it will be a <em>separate paragraph</em>.</p><p>This line is also a separate paragraph, but... This line is only separated by a single newline, so it&#x27;s a separate line in the <em>same paragraph</em>.</p><hr/><h2>Admonitions</h2><p>:::note</p><p>This is a note</p><p>:::</p><p>:::tip</p><p>This is a tip</p><p>:::</p><p>:::important</p><p>This is important</p><p>:::</p><p>:::caution</p><p>This is a caution</p><p>:::</p><p>:::warning</p><p>This is a warning</p><p>:::</p><h2>My Logos</h2><p><code>右键 -&gt; 复制图片地址</code> 使用<br/>
<img src="http://static.yximgs.com/udata/pkg/userGrowth-fe-infra/user-profile-bear-logo-big.ico" alt="logo-big.ico"/>
<img src="http://static.yximgs.com/udata/pkg/userGrowth-fe-infra/user-profile-bear-logo.ico" alt="logo.ico"/>
<img src="http://static.yximgs.com/udata/pkg/userGrowth-fe-infra/user-profile-bear-logo.png" alt="logo.png"/>
<img src="http://static.yximgs.com/udata/pkg/userGrowth-fe-infra/user-profile-bear-logo.svg" alt="logo.svg"/></p>]]></content:encoded>
        </item>
    </channel>
</rss>